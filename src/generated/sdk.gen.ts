// This file is auto-generated by @hey-api/openapi-ts

import { createClient, createConfig, type OptionsLegacyParser, formDataBodySerializer } from '@hey-api/client-fetch';
import type { DownloadYouTubeVideoData, DownloadYouTubeVideoError, DownloadYouTubeVideoResponse, GetYouTubeTranscriptData, GetYouTubeTranscriptError, GetYouTubeTranscriptResponse, DownloadInstagramMediaData, DownloadInstagramMediaError, DownloadInstagramMediaResponse, CheckInstagramHashtagsData, CheckInstagramHashtagsError, CheckInstagramHashtagsResponse, DownloadTikTokVideoData, DownloadTikTokVideoError, DownloadTikTokVideoResponse, DownloadTwitterMediaData, DownloadTwitterMediaError, DownloadTwitterMediaResponse, DownloadFacebookVideoData, DownloadFacebookVideoError, DownloadFacebookVideoResponse, DownloadLinkedInVideoData, DownloadLinkedInVideoError, DownloadLinkedInVideoResponse, DownloadBlueskyMediaData, DownloadBlueskyMediaError, DownloadBlueskyMediaResponse, GetAnalyticsData, GetAnalyticsError, GetAnalyticsResponse, GetYouTubeDailyViewsData, GetYouTubeDailyViewsError, GetYouTubeDailyViewsResponse, ListAccountGroupsError, ListAccountGroupsResponse, CreateAccountGroupData, CreateAccountGroupError, CreateAccountGroupResponse, UpdateAccountGroupData, UpdateAccountGroupError, UpdateAccountGroupResponse, DeleteAccountGroupData, DeleteAccountGroupError, DeleteAccountGroupResponse, GetMediaPresignedUrlData, GetMediaPresignedUrlError, GetMediaPresignedUrlResponse, SearchRedditData, SearchRedditError, SearchRedditResponse, GetRedditFeedData, GetRedditFeedError, GetRedditFeedResponse, GetUsageStatsError, GetUsageStatsResponse, ListPostsData, ListPostsError, ListPostsResponse, CreatePostData, CreatePostError, CreatePostResponse, GetPostData, GetPostError, GetPostResponse, UpdatePostData, UpdatePostError, UpdatePostResponse, DeletePostData, DeletePostError, DeletePostResponse, BulkUploadPostsData, BulkUploadPostsError, BulkUploadPostsResponse, RetryPostData, RetryPostError, RetryPostResponse, ListUsersError, ListUsersResponse, GetUserData, GetUserError, GetUserResponse, ListProfilesData, ListProfilesError, ListProfilesResponse, CreateProfileData, CreateProfileError, CreateProfileResponse, GetProfileData, GetProfileError, GetProfileResponse, UpdateProfileData, UpdateProfileError, UpdateProfileResponse, DeleteProfileData, DeleteProfileError, DeleteProfileResponse, ListAccountsData, ListAccountsError, ListAccountsResponse, GetFollowerStatsData, GetFollowerStatsError, GetFollowerStatsResponse, UpdateAccountData, UpdateAccountError, UpdateAccountResponse, DeleteAccountData, DeleteAccountError, DeleteAccountResponse, GetAllAccountsHealthData, GetAllAccountsHealthError, GetAllAccountsHealthResponse, GetAccountHealthData, GetAccountHealthError, GetAccountHealthResponse, ListApiKeysError, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyError, CreateApiKeyResponse, DeleteApiKeyData, DeleteApiKeyError, DeleteApiKeyResponse, CreateInviteTokenData, CreateInviteTokenError, CreateInviteTokenResponse, GetConnectUrlData, GetConnectUrlError, GetConnectUrlResponse, HandleOAuthCallbackData, HandleOAuthCallbackError, HandleOAuthCallbackResponse, ListFacebookPagesData, ListFacebookPagesError, ListFacebookPagesResponse, SelectFacebookPageData, SelectFacebookPageError, SelectFacebookPageResponse, ListGoogleBusinessLocationsData, ListGoogleBusinessLocationsError, ListGoogleBusinessLocationsResponse, SelectGoogleBusinessLocationData, SelectGoogleBusinessLocationError, SelectGoogleBusinessLocationResponse, GetGoogleBusinessReviewsData, GetGoogleBusinessReviewsError, GetGoogleBusinessReviewsResponse, GetGoogleBusinessFoodMenusData, GetGoogleBusinessFoodMenusError, GetGoogleBusinessFoodMenusResponse, UpdateGoogleBusinessFoodMenusData, UpdateGoogleBusinessFoodMenusError, UpdateGoogleBusinessFoodMenusResponse, GetPendingOAuthDataData, GetPendingOAuthDataError, GetPendingOAuthDataResponse, ListLinkedInOrganizationsData, ListLinkedInOrganizationsError, ListLinkedInOrganizationsResponse, SelectLinkedInOrganizationData, SelectLinkedInOrganizationError, SelectLinkedInOrganizationResponse, ListPinterestBoardsForSelectionData, ListPinterestBoardsForSelectionError, ListPinterestBoardsForSelectionResponse, SelectPinterestBoardData, SelectPinterestBoardError, SelectPinterestBoardResponse, ListSnapchatProfilesData, ListSnapchatProfilesError, ListSnapchatProfilesResponse, SelectSnapchatProfileData, SelectSnapchatProfileError, SelectSnapchatProfileResponse, ConnectBlueskyCredentialsData, ConnectBlueskyCredentialsError, ConnectBlueskyCredentialsResponse, GetTelegramConnectStatusData, GetTelegramConnectStatusError, GetTelegramConnectStatusResponse, InitiateTelegramConnectData, InitiateTelegramConnectError, InitiateTelegramConnectResponse, CompleteTelegramConnectData, CompleteTelegramConnectError, CompleteTelegramConnectResponse, GetFacebookPagesData, GetFacebookPagesError, GetFacebookPagesResponse, UpdateFacebookPageData, UpdateFacebookPageError, UpdateFacebookPageResponse, GetLinkedInOrganizationsData, GetLinkedInOrganizationsError, GetLinkedInOrganizationsResponse, GetLinkedInAggregateAnalyticsData, GetLinkedInAggregateAnalyticsError, GetLinkedInAggregateAnalyticsResponse, GetLinkedInPostAnalyticsData, GetLinkedInPostAnalyticsError, GetLinkedInPostAnalyticsResponse, UpdateLinkedInOrganizationData, UpdateLinkedInOrganizationError, UpdateLinkedInOrganizationResponse, GetLinkedInMentionsData, GetLinkedInMentionsError, GetLinkedInMentionsResponse, GetPinterestBoardsData, GetPinterestBoardsError, GetPinterestBoardsResponse, UpdatePinterestBoardsData, UpdatePinterestBoardsError, UpdatePinterestBoardsResponse, GetGmbLocationsData, GetGmbLocationsError, GetGmbLocationsResponse, UpdateGmbLocationData, UpdateGmbLocationError, UpdateGmbLocationResponse, GetRedditSubredditsData, GetRedditSubredditsError, GetRedditSubredditsResponse, UpdateRedditSubredditsData, UpdateRedditSubredditsError, UpdateRedditSubredditsResponse, ListQueueSlotsData, ListQueueSlotsError, ListQueueSlotsResponse, CreateQueueSlotData, CreateQueueSlotError, CreateQueueSlotResponse, UpdateQueueSlotData, UpdateQueueSlotError, UpdateQueueSlotResponse, DeleteQueueSlotData, DeleteQueueSlotError, DeleteQueueSlotResponse, PreviewQueueData, PreviewQueueError, PreviewQueueResponse, GetNextQueueSlotData, GetNextQueueSlotError, GetNextQueueSlotResponse, GetWebhookSettingsError, GetWebhookSettingsResponse, CreateWebhookSettingsData, CreateWebhookSettingsError, CreateWebhookSettingsResponse, UpdateWebhookSettingsData, UpdateWebhookSettingsError, UpdateWebhookSettingsResponse, DeleteWebhookSettingsData, DeleteWebhookSettingsError, DeleteWebhookSettingsResponse, TestWebhookData, TestWebhookError, TestWebhookResponse, GetWebhookLogsData, GetWebhookLogsError, GetWebhookLogsResponse, ListLogsData, ListLogsError, ListLogsResponse, GetLogData, GetLogError, GetLogResponse, GetPostLogsData, GetPostLogsError, GetPostLogsResponse, ListInboxConversationsData, ListInboxConversationsError, ListInboxConversationsResponse, GetInboxConversationData, GetInboxConversationError, GetInboxConversationResponse, UpdateInboxConversationData, UpdateInboxConversationError, UpdateInboxConversationResponse, GetInboxConversationMessagesData, GetInboxConversationMessagesError, GetInboxConversationMessagesResponse, SendInboxMessageData, SendInboxMessageError, SendInboxMessageResponse, ListInboxCommentsData, ListInboxCommentsError, ListInboxCommentsResponse, GetInboxPostCommentsData, GetInboxPostCommentsError, GetInboxPostCommentsResponse, ReplyToInboxPostData, ReplyToInboxPostError, ReplyToInboxPostResponse, DeleteInboxCommentData, DeleteInboxCommentError, DeleteInboxCommentResponse, HideInboxCommentData, HideInboxCommentError, HideInboxCommentResponse, UnhideInboxCommentData, UnhideInboxCommentError, UnhideInboxCommentResponse, LikeInboxCommentData, LikeInboxCommentError, LikeInboxCommentResponse, UnlikeInboxCommentData, UnlikeInboxCommentError, UnlikeInboxCommentResponse, SendPrivateReplyToCommentData, SendPrivateReplyToCommentError, SendPrivateReplyToCommentResponse, ListInboxReviewsData, ListInboxReviewsError, ListInboxReviewsResponse, ReplyToInboxReviewData, ReplyToInboxReviewError, ReplyToInboxReviewResponse, DeleteInboxReviewReplyData, DeleteInboxReviewReplyError, DeleteInboxReviewReplyResponse } from './types.gen';

export const client = createClient(createConfig());

/**
 * Download YouTube video or audio
 * Download YouTube videos or audio. Returns available formats or direct download URL.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadYouTubeVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadYouTubeVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadYouTubeVideoResponse, DownloadYouTubeVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/youtube/download'
    });
};

/**
 * Get YouTube video transcript
 * Extract transcript/captions from a YouTube video.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const getYouTubeTranscript = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetYouTubeTranscriptData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetYouTubeTranscriptResponse, GetYouTubeTranscriptError, ThrowOnError>({
        ...options,
        url: '/v1/tools/youtube/transcript'
    });
};

/**
 * Download Instagram reel or post
 * Download Instagram reels, posts, or photos.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadInstagramMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadInstagramMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadInstagramMediaResponse, DownloadInstagramMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/instagram/download'
    });
};

/**
 * Check Instagram hashtags for bans
 * Check if Instagram hashtags are banned, restricted, or safe to use.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const checkInstagramHashtags = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CheckInstagramHashtagsData, ThrowOnError>) => {
    return (options?.client ?? client).post<CheckInstagramHashtagsResponse, CheckInstagramHashtagsError, ThrowOnError>({
        ...options,
        url: '/v1/tools/instagram/hashtag-checker'
    });
};

/**
 * Download TikTok video
 * Download TikTok videos with or without watermark.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadTikTokVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadTikTokVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadTikTokVideoResponse, DownloadTikTokVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/tiktok/download'
    });
};

/**
 * Download Twitter/X video
 * Download videos from Twitter/X posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadTwitterMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadTwitterMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadTwitterMediaResponse, DownloadTwitterMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/twitter/download'
    });
};

/**
 * Download Facebook video
 * Download videos and reels from Facebook.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadFacebookVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadFacebookVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadFacebookVideoResponse, DownloadFacebookVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/facebook/download'
    });
};

/**
 * Download LinkedIn video
 * Download videos from LinkedIn posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadLinkedInVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadLinkedInVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadLinkedInVideoResponse, DownloadLinkedInVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/linkedin/download'
    });
};

/**
 * Download Bluesky video
 * Download videos from Bluesky posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadBlueskyMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadBlueskyMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadBlueskyMediaResponse, DownloadBlueskyMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/bluesky/download'
    });
};

/**
 * Unified analytics for posts
 * Returns analytics for posts. If postId is provided, returns analytics for a single post.
 * Otherwise returns a paginated list of posts with overview stats.
 *
 * **Important: Understanding Post IDs**
 *
 * This endpoint uses two types of posts:
 * - **Late Posts** - Posts scheduled/created via the Late API (e.g., via `POST /v1/posts`)
 * - **External Posts** - Posts synced from social platforms for analytics tracking
 *
 * When you schedule a post via Late and it gets published, **both** records exist:
 * 1. The original Late Post (returned when you created the post)
 * 2. An External Post (created when we sync analytics from the platform)
 *
 * **List endpoint behavior:**
 * - Returns External Post IDs (`_id` field)
 * - Use the `isExternal` field to identify post origin:
 * - `isExternal: true` - Synced from platform (may have been originally scheduled via Late)
 * - `isExternal: false` - Late-scheduled post (shown when querying by Late post ID)
 *
 * **Single post behavior (`postId` parameter):**
 * - Accepts **both** Late Post IDs and External Post IDs
 * - If you pass a Late Post ID, the API automatically resolves it to the corresponding External Post analytics
 * - Both return the same analytics data for the same underlying social media post
 *
 * **Correlating posts:** Use `latePostId` to link analytics entries back to the original post created via `POST /v1/posts`. This field contains the Late Post ID when the external post originated from Late. Alternatively, use `platformPostUrl` (e.g., `https://www.instagram.com/reel/ABC123/`) as a stable identifier.
 *
 * **Note:** For follower count history and growth metrics, use the dedicated `/v1/accounts/follower-stats` endpoint.
 *
 * **LinkedIn Analytics:**
 * - **Personal Accounts:** Per-post analytics available for posts published through Late. External posts cannot be synced due to LinkedIn API restrictions.
 * - **Organization Accounts:** Full analytics support including external post syncing.
 *
 * **Telegram Analytics:**
 * - **Not available.** The Telegram Bot API does not provide message view counts, forwards, or engagement metrics. This is a Telegram platform limitation, not a Late limitation. View counts are only visible to channel admins in the Telegram app.
 *
 * **Data Freshness:** Analytics data is cached and refreshed at most once per hour. When you call this endpoint, if the cache is older than 60 minutes, a background refresh is triggered and you'll see updated data on subsequent requests. There is no rate limit on API requests.
 *
 */
export const getAnalytics = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAnalyticsResponse, GetAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/analytics'
    });
};

/**
 * YouTube daily views breakdown
 * Returns historical daily view counts for a specific YouTube video.
 * Uses YouTube Analytics API v2 to fetch daily breakdowns including views,
 * watch time, and subscriber changes.
 *
 * **Required Scope:** This endpoint requires the `yt-analytics.readonly` OAuth scope.
 * Existing YouTube accounts may need to re-authorize to grant this permission.
 * If the scope is missing, the response will include a `reauthorizeUrl`.
 *
 * **Data Latency:** YouTube Analytics data has a 2-3 day delay. The `endDate`
 * is automatically capped to 3 days ago.
 *
 * **Date Range:** Maximum 90 days of historical data available. Defaults to last 30 days.
 *
 */
export const getYouTubeDailyViews = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetYouTubeDailyViewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetYouTubeDailyViewsResponse, GetYouTubeDailyViewsError, ThrowOnError>({
        ...options,
        url: '/v1/analytics/youtube/daily-views'
    });
};

/**
 * List account groups for the authenticated user
 */
export const listAccountGroups = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListAccountGroupsResponse, ListAccountGroupsError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups'
    });
};

/**
 * Create a new account group
 */
export const createAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateAccountGroupResponse, CreateAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups'
    });
};

/**
 * Update an account group
 */
export const updateAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateAccountGroupResponse, UpdateAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups/{groupId}'
    });
};

/**
 * Delete an account group
 */
export const deleteAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteAccountGroupResponse, DeleteAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups/{groupId}'
    });
};

/**
 * Get a presigned URL for direct file upload (up to 5GB)
 * Get a presigned URL to upload files directly to cloud storage. This is the recommended method for uploading files of any size, especially files larger than ~4MB.
 *
 * **How it works:**
 * 1. Call this endpoint with the filename and content type
 * 2. Receive an `uploadUrl` (presigned) and `publicUrl`
 * 3. PUT your file directly to the `uploadUrl`
 * 4. Use the `publicUrl` in your posts
 *
 * **Benefits:**
 * - Supports files up to 5GB
 * - Files upload directly to storage (faster, no server bottleneck)
 * - No 413 errors from server body size limits
 *
 * **Example:**
 * ```javascript
 * // Step 1: Get presigned URL
 * const response = await fetch('https://getlate.dev/api/v1/media/presign', {
 * method: 'POST',
 * headers: {
 * 'Authorization': 'Bearer YOUR_API_KEY',
 * 'Content-Type': 'application/json'
 * },
 * body: JSON.stringify({
 * filename: 'my-video.mp4',
 * contentType: 'video/mp4'
 * })
 * });
 * const { uploadUrl, publicUrl } = await response.json();
 *
 * // Step 2: Upload file directly to storage
 * await fetch(uploadUrl, {
 * method: 'PUT',
 * body: file,
 * headers: { 'Content-Type': 'video/mp4' }
 * });
 *
 * // Step 3: Use publicUrl when creating your post
 * // The publicUrl is ready to use immediately after upload completes
 * ```
 *
 */
export const getMediaPresignedUrl = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetMediaPresignedUrlData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetMediaPresignedUrlResponse, GetMediaPresignedUrlError, ThrowOnError>({
        ...options,
        url: '/v1/media/presign'
    });
};

/**
 * Search Reddit posts via a connected account
 */
export const searchReddit = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SearchRedditData, ThrowOnError>) => {
    return (options?.client ?? client).get<SearchRedditResponse, SearchRedditError, ThrowOnError>({
        ...options,
        url: '/v1/reddit/search'
    });
};

/**
 * Fetch subreddit feed via a connected account
 */
export const getRedditFeed = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetRedditFeedData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRedditFeedResponse, GetRedditFeedError, ThrowOnError>({
        ...options,
        url: '/v1/reddit/feed'
    });
};

/**
 * Get plan and usage stats for current account
 */
export const getUsageStats = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsageStatsResponse, GetUsageStatsError, ThrowOnError>({
        ...options,
        url: '/v1/usage-stats'
    });
};

/**
 * List posts visible to the authenticated user
 * **Getting Post URLs:**
 * For published posts, each platform entry includes `platformPostUrl` with the public URL.
 * Use `status=published` filter to fetch only published posts with their URLs.
 *
 * Notes and constraints by platform when interpreting the response:
 * - YouTube: posts always include at least one video in mediaItems.
 * - Instagram/TikTok: posts always include media; drafts may omit media until finalized in client.
 * - TikTok: mediaItems will not mix photos and videos in the same post.
 *
 */
export const listPosts = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListPostsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPostsResponse, ListPostsError, ThrowOnError>({
        ...options,
        url: '/v1/posts'
    });
};

/**
 * Create a draft, scheduled, or immediate post
 * **Getting Post URLs:**
 * - For immediate posts (`publishNow: true`): The response includes `platformPostUrl` in each platform entry under `post.platforms[]`.
 * - For scheduled posts: Fetch the post via `GET /v1/posts/{postId}` after the scheduled time; `platformPostUrl` will be populated once published.
 *
 * **Content/Caption requirements:**
 * - `content` (caption/description) is optional when:
 * - Media is attached (`mediaItems` or per-platform `customMedia`)
 * - All platforms have `customContent` set
 * - Posting only to YouTube (title is used instead)
 * - Text-only posts (no media) require `content`
 * - Stories do not use captions (content is ignored)
 * - Reels, feed posts, and other media posts can have optional captions
 *
 * Platform constraints:
 * - YouTube requires a video in mediaItems; optional custom thumbnail via MediaItem.thumbnail.
 * - Instagram and TikTok require media; do not mix videos and images for TikTok.
 * - Instagram carousels support up to 10 items; Stories publish as 'story'.
 * - Threads carousels support up to 10 images (no videos in carousels); single posts support one image or video.
 * - Facebook Stories require media (single image or video); set contentType to 'story' in platformSpecificData.
 * - LinkedIn multi-image supports up to 20 images; single PDF documents supported (max 100MB, ~300 pages, cannot mix with other media).
 * - Pinterest supports single image via image_url or a single video per Pin; boardId is required.
 * - Bluesky supports up to 4 images per post. Images may be automatically recompressed to ≤ ~1MB to satisfy Bluesky's blob limit. When no media is attached, a link preview may be generated for URLs in the text.
 * - Snapchat requires media (single image or video); set contentType to 'story', 'saved_story', or 'spotlight' in platformSpecificData. Stories are ephemeral (24h), Saved Stories are permanent, Spotlight is for video content.
 *
 * **Multi-page/multi-location posting:**
 * Some platforms allow posting to multiple pages, organizations, or locations from a single account connection.
 * Use the same accountId multiple times with different targets in platformSpecificData:
 * - Facebook: `pageId` - post to multiple Facebook Pages (list via GET /v1/accounts/{id}/facebook-page)
 * - LinkedIn: `organizationUrn` - post to multiple organizations (list via GET /v1/accounts/{id}/linkedin-organizations)
 * - Google Business: `locationId` - post to multiple locations (list via GET /v1/accounts/{id}/gmb-locations)
 * - Reddit: `subreddit` - post to multiple subreddits from the same account
 *
 */
export const createPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreatePostResponse, CreatePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts'
    });
};

/**
 * Get a single post
 * Fetch a single post by ID. For published posts, this returns `platformPostUrl`
 * for each platform - useful for retrieving post URLs after scheduled posts publish.
 *
 */
export const getPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPostData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPostResponse, GetPostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Update a post
 * Update an existing post. Only draft, scheduled, failed, and partial posts can be edited.
 * Published, publishing, and cancelled posts cannot be modified.
 *
 */
export const updatePost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdatePostData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdatePostResponse, UpdatePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Delete a post
 * Delete a post. Published posts cannot be deleted.
 * When deleting a scheduled or draft post that consumed upload quota, the quota will be automatically refunded.
 *
 */
export const deletePost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeletePostData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeletePostResponse, DeletePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Validate and schedule multiple posts from CSV
 */
export const bulkUploadPosts = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<BulkUploadPostsData, ThrowOnError>) => {
    return (options?.client ?? client).post<BulkUploadPostsResponse, BulkUploadPostsError, ThrowOnError>({
        ...options,
        ...formDataBodySerializer,
        headers: {
            'Content-Type': null,
            ...options?.headers
        },
        url: '/v1/posts/bulk-upload'
    });
};

/**
 * Retry publishing a failed or partial post
 */
export const retryPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<RetryPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<RetryPostResponse, RetryPostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}/retry'
    });
};

/**
 * List team users (root + invited)
 */
export const listUsers = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListUsersResponse, ListUsersError, ThrowOnError>({
        ...options,
        url: '/v1/users'
    });
};

/**
 * Get user by id (self or invited)
 */
export const getUser = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetUserData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUserResponse, GetUserError, ThrowOnError>({
        ...options,
        url: '/v1/users/{userId}'
    });
};

/**
 * List profiles visible to the authenticated user
 * Returns profiles within the user's plan limit. Profiles are sorted by creation date (oldest first).
 * Use `includeOverLimit=true` to include profiles that exceed the plan limit (for management/deletion purposes).
 *
 */
export const listProfiles = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListProfilesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListProfilesResponse, ListProfilesError, ThrowOnError>({
        ...options,
        url: '/v1/profiles'
    });
};

/**
 * Create a new profile
 */
export const createProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateProfileData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateProfileResponse, CreateProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles'
    });
};

/**
 * Get a profile by id
 */
export const getProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetProfileData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetProfileResponse, GetProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * Update a profile
 */
export const updateProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateProfileData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateProfileResponse, UpdateProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * Delete a profile (must have no connected accounts)
 */
export const deleteProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteProfileData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteProfileResponse, DeleteProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * List connected social accounts
 * Returns list of connected social accounts.
 * By default, only returns accounts from profiles within the user's plan limit.
 * Follower count data (followersCount, followersLastUpdated) is only included if user has analytics add-on.
 *
 */
export const listAccounts = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListAccountsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListAccountsResponse, ListAccountsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts'
    });
};

/**
 * Get follower stats and growth metrics
 * Returns follower count history and growth metrics for connected social accounts.
 * **Requires analytics add-on subscription.**
 *
 * **Data Freshness:** Follower counts are automatically refreshed once per day.
 *
 */
export const getFollowerStats = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetFollowerStatsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFollowerStatsResponse, GetFollowerStatsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/follower-stats'
    });
};

/**
 * Update a social account
 */
export const updateAccount = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateAccountData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateAccountResponse, UpdateAccountError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}'
    });
};

/**
 * Disconnect a social account
 */
export const deleteAccount = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteAccountData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteAccountResponse, DeleteAccountError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}'
    });
};

/**
 * Check health of all connected accounts
 * Returns the health status of all connected social accounts, including token validity,
 * permissions status, and any issues that need attention. Useful for monitoring account
 * connections and identifying accounts that need reconnection.
 *
 */
export const getAllAccountsHealth = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetAllAccountsHealthData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAllAccountsHealthResponse, GetAllAccountsHealthError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/health'
    });
};

/**
 * Check health of a specific account
 * Returns detailed health information for a specific social account, including token status,
 * granted permissions, missing permissions, and actionable recommendations.
 *
 */
export const getAccountHealth = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetAccountHealthData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAccountHealthResponse, GetAccountHealthError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/health'
    });
};

/**
 * List API keys for the current user
 */
export const listApiKeys = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListApiKeysResponse, ListApiKeysError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys'
    });
};

/**
 * Create a new API key
 */
export const createApiKey = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateApiKeyData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateApiKeyResponse, CreateApiKeyError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys'
    });
};

/**
 * Delete an API key
 */
export const deleteApiKey = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteApiKeyData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteApiKeyResponse, DeleteApiKeyError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys/{keyId}'
    });
};

/**
 * Create a team member invite token
 * Generate a secure invite link to grant team members access to your profiles.
 * Invites expire after 7 days and are single-use.
 *
 */
export const createInviteToken = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateInviteTokenData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateInviteTokenResponse, CreateInviteTokenError, ThrowOnError>({
        ...options,
        url: '/v1/invite/tokens'
    });
};

/**
 * Start OAuth connection for a platform
 * Initiate an OAuth connection flow for any supported social media platform.
 *
 * **Standard Flow (Hosted UI):**
 * For Facebook connections, Late hosts the page selection UI:
 *
 * 1. Call this endpoint with your API key and `redirect_url` (optional)
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, the user is redirected to Late’s hosted page selector at
 * `/connect/facebook/select-page?profileId=X&tempToken=Y&userProfile=Z&redirect_url=YOUR_URL&connect_token=CT`
 * 4. After they pick a page, Late saves the connection and finally redirects to your `redirect_url` (if provided)
 *
 * **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest & Google Business Profile):**
 * Build your own fully branded selection UI while Late handles OAuth:
 *
 * **Facebook:**
 * 1. Call this endpoint with your API key and add `&headless=true`, e.g.
 * `GET /v1/connect/facebook?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:
 * - `profileId` – your Late profile ID
 * - `tempToken` – temporary Facebook access token
 * - `userProfile` – URL‑encoded JSON user profile
 * - `connect_token` – short‑lived connect token (for API auth)
 * - `platform=facebook`
 * - `step=select_page`
 * 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:
 * - `GET /v1/connect/facebook/select-page` to fetch pages
 * - `POST /v1/connect/facebook/select-page` to save the selected page
 * 5. In this mode, users never see Late's hosted page selector – only your UI.
 *
 * **LinkedIn:**
 * 1. Call this endpoint with `&headless=true`, e.g.
 * `GET /v1/connect/linkedin?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:
 * - `profileId` – your Late profile ID
 * - `pendingDataToken` – token to fetch OAuth data via API (see step 4)
 * - `connect_token` – short-lived connect token (for API auth)
 * - `platform=linkedin`
 * - `step=select_organization`
 * 4. Call `GET /v1/connect/pending-data?token=PENDING_DATA_TOKEN` to fetch the OAuth data:
 * - `tempToken` – temporary LinkedIn access token
 * - `userProfile` – JSON object with `id`, `username`, `displayName`, `profilePicture`
 * - `organizations` – JSON array with `id`, `urn`, `name`, `vanityName` for each org
 * - `refreshToken` / `expiresIn` – token metadata
 * This endpoint is one-time use and data expires after 10 minutes.
 * 5. **Optional:** To fetch full organization details (logos, website, industry, description), call `GET /v1/connect/linkedin/organizations?tempToken=X&orgIds=id1,id2,...`
 * 6. Call `POST /v1/connect/linkedin/select-organization` with the `X-Connect-Token` header to save the selection.
 * 7. In this mode, users never see Late's hosted organization selector – only your UI.
 * 8. Note: If the user has no organization admin access, `step=select_organization` will NOT be present,
 * and the account will be connected directly as a personal account.
 *
 * **Pinterest:**
 * 1. Call this endpoint with `&headless=true`, e.g.
 * `GET /v1/connect/pinterest?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:
 * - `profileId` – your Late profile ID
 * - `tempToken` – temporary Pinterest access token
 * - `userProfile` – URL‑encoded JSON user profile
 * - `connect_token` – short‑lived connect token (for API auth)
 * - `platform=pinterest`
 * - `step=select_board`
 * 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:
 * - `GET /v1/connect/pinterest/select-board` to fetch boards
 * - `POST /v1/connect/pinterest/select-board` to save the selected board
 * 5. In this mode, users never see Late's hosted board selector – only your UI.
 *
 * **Google Business Profile:**
 * 1. Call this endpoint with `&headless=true`, e.g.
 * `GET /v1/connect/googlebusiness?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, the user is redirected directly to **your** `redirect_url` with:
 * - `profileId` – your Late profile ID
 * - `tempToken` – temporary Google access token
 * - `userProfile` – URL‑encoded JSON user profile (includes refresh token info)
 * - `connect_token` – short‑lived connect token (for API auth)
 * - `platform=googlebusiness`
 * - `step=select_location`
 * 4. Use `tempToken`, `userProfile`, and the `X-Connect-Token` header with:
 * - `GET /v1/connect/googlebusiness/locations` to fetch business locations
 * - `POST /v1/connect/googlebusiness/select-location` to save the selected location
 * 5. In this mode, users never see Late's hosted location selector – only your UI.
 *
 */
export const getConnectUrl = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetConnectUrlData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetConnectUrlResponse, GetConnectUrlError, ThrowOnError>({
        ...options,
        url: '/v1/connect/{platform}'
    });
};

/**
 * Complete OAuth token exchange manually (for server-side flows)
 */
export const handleOAuthCallback = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<HandleOAuthCallbackData, ThrowOnError>) => {
    return (options?.client ?? client).post<HandleOAuthCallbackResponse, HandleOAuthCallbackError, ThrowOnError>({
        ...options,
        url: '/v1/connect/{platform}'
    });
};

/**
 * List Facebook Pages after OAuth (Headless Mode)
 * **Headless Mode for Custom UI**
 *
 * After initiating Facebook OAuth via `/v1/connect/facebook`, you'll be redirected to
 * `/connect/facebook/select-page` with query params including `tempToken` and `userProfile`.
 *
 * For a **headless/whitelabeled flow**, extract these params from the URL and call this
 * endpoint to retrieve the list of Facebook Pages the user can manage. Then build your
 * own UI to let users select a page.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key
 * (rather than a browser session).
 *
 */
export const listFacebookPages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListFacebookPagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListFacebookPagesResponse, ListFacebookPagesError, ThrowOnError>({
        ...options,
        url: '/v1/connect/facebook/select-page'
    });
};

/**
 * Select a Facebook Page to complete the connection (Headless Mode)
 * **Complete the Headless Flow**
 *
 * After displaying your custom UI with the list of pages from the GET endpoint, call this
 * endpoint to finalize the connection with the user's selected page.
 *
 * The `userProfile` should be the decoded JSON object from the `userProfile` query param
 * in the OAuth callback redirect URL.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectFacebookPage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectFacebookPageData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectFacebookPageResponse, SelectFacebookPageError, ThrowOnError>({
        ...options,
        url: '/v1/connect/facebook/select-page'
    });
};

/**
 * List Google Business Locations after OAuth (Headless Mode)
 * **Headless Mode for Custom UI**
 *
 * After initiating Google Business OAuth via `/v1/connect/googlebusiness?headless=true`, you'll be redirected
 * to your `redirect_url` with query params including `tempToken` and `userProfile`.
 *
 * For a **headless/whitelabeled flow**, extract these params from the URL and call this
 * endpoint to retrieve the list of Google Business locations the user can manage. Then build your
 * own UI to let users select a location.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key
 * (rather than a browser session).
 *
 */
export const listGoogleBusinessLocations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListGoogleBusinessLocationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListGoogleBusinessLocationsResponse, ListGoogleBusinessLocationsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/googlebusiness/locations'
    });
};

/**
 * Select a Google Business location to complete the connection (Headless Mode)
 * **Complete the Headless Flow**
 *
 * After displaying your custom UI with the list of locations from the GET `/v1/connect/googlebusiness/locations`
 * endpoint, call this endpoint to finalize the connection with the user's selected location.
 *
 * The `userProfile` should be the decoded JSON object from the `userProfile` query param
 * in the OAuth callback redirect URL. It contains important token information (including refresh token).
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectGoogleBusinessLocation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectGoogleBusinessLocationData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectGoogleBusinessLocationResponse, SelectGoogleBusinessLocationError, ThrowOnError>({
        ...options,
        url: '/v1/connect/googlebusiness/select-location'
    });
};

/**
 * Get Google Business Profile reviews
 * Fetches reviews for a connected Google Business Profile account.
 *
 * Returns all reviews for the business location, including:
 * - Reviewer information (name, profile photo)
 * - Star rating (1-5)
 * - Review comment/text
 * - Business owner's reply (if any)
 * - Review timestamps
 *
 * Use pagination via `nextPageToken` to fetch all reviews for locations with many reviews.
 *
 */
export const getGoogleBusinessReviews = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessReviewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessReviewsResponse, GetGoogleBusinessReviewsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-reviews'
    });
};

/**
 * Get Google Business Profile food menus
 * Fetches food menus for a connected Google Business Profile location.
 *
 * Returns the full menu structure including:
 * - Menu names and descriptions
 * - Sections (e.g. Appetizers, Entrees, Drinks)
 * - Items with labels, pricing, dietary info, and allergens
 * - Item options/variants
 *
 * Only available for locations with food menu support (restaurants, cafes, etc.).
 *
 */
export const getGoogleBusinessFoodMenus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessFoodMenusData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessFoodMenusResponse, GetGoogleBusinessFoodMenusError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-food-menus'
    });
};

/**
 * Update Google Business Profile food menus
 * Updates the food menus for a connected Google Business Profile location.
 *
 * Send the full menus array. Use `updateMask` for partial updates (e.g. `"menus"` to only update the menus field).
 *
 * Each menu can contain sections, and each section can contain items with pricing, dietary restrictions, allergens, and more.
 *
 */
export const updateGoogleBusinessFoodMenus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGoogleBusinessFoodMenusData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGoogleBusinessFoodMenusResponse, UpdateGoogleBusinessFoodMenusError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-food-menus'
    });
};

/**
 * Fetch pending OAuth selection data (Headless Mode)
 * **Fetch Pending OAuth Data for Headless Mode**
 *
 * In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.)
 * in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors
 * when users have many organizations/pages to select from.
 *
 * After OAuth redirect, use the `pendingDataToken` from the URL to fetch the stored data.
 *
 * **Important:**
 * - This endpoint is one-time use: data is deleted after being fetched
 * - Data expires automatically after 10 minutes if not fetched
 * - No authentication required, just the token from the redirect URL
 *
 */
export const getPendingOAuthData = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPendingOAuthDataData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPendingOAuthDataResponse, GetPendingOAuthDataError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pending-data'
    });
};

/**
 * Fetch full LinkedIn organization details (Headless Mode)
 * **Fetch Full Organization Details for Custom UI**
 *
 * After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only
 * `id`, `urn`, and `name` fields (additional details are excluded to prevent URL length issues with many organizations).
 *
 * Use this endpoint to fetch full organization details including logos, vanity names, websites, and more
 * if you want to display them in your custom selection UI.
 *
 * **Note:** This endpoint requires no authentication - just the `tempToken` from the OAuth redirect.
 * Details are fetched directly from LinkedIn's API in parallel for fast response times.
 *
 */
export const listLinkedInOrganizations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListLinkedInOrganizationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListLinkedInOrganizationsResponse, ListLinkedInOrganizationsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/linkedin/organizations'
    });
};

/**
 * Select LinkedIn organization or personal account after OAuth
 * **Complete the LinkedIn Connection Flow**
 *
 * After OAuth, the user is redirected with `organizations` in the URL params (if they have org admin access).
 * The organizations array contains `id`, `urn`, and `name` fields. Use this data to build your UI,
 * then call this endpoint to save the selection.
 *
 * Set `accountType` to `personal` to connect as the user's personal LinkedIn profile, or
 * `organization` to connect as a company page (requires `selectedOrganization` object).
 *
 * **Personal Profile:** To connect a personal LinkedIn account, set `accountType` to `"personal"`
 * and **omit** the `selectedOrganization` field entirely. This is the simplest flow.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectLinkedInOrganization = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectLinkedInOrganizationData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectLinkedInOrganizationResponse, SelectLinkedInOrganizationError, ThrowOnError>({
        ...options,
        url: '/v1/connect/linkedin/select-organization'
    });
};

/**
 * List Pinterest Boards after OAuth (Headless Mode)
 * **Retrieve Pinterest Boards for Selection UI**
 *
 * After initiating Pinterest OAuth via `/v1/connect/pinterest` with `headless=true`, you'll be redirected to
 * your `redirect_url` with query params including `tempToken` and `userProfile`.
 *
 * If you want to build your own fully-branded board selector (instead of Late's hosted UI), call this
 * endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your
 * UI and call `POST /v1/connect/pinterest/select-board` to save the selection.
 *
 * **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL.
 *
 */
export const listPinterestBoardsForSelection = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListPinterestBoardsForSelectionData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPinterestBoardsForSelectionResponse, ListPinterestBoardsForSelectionError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pinterest/select-board'
    });
};

/**
 * Select a Pinterest Board to complete the connection (Headless Mode)
 * **Complete the Pinterest Connection Flow**
 *
 * After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectPinterestBoard = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectPinterestBoardData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectPinterestBoardResponse, SelectPinterestBoardError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pinterest/select-board'
    });
};

/**
 * List Snapchat Public Profiles after OAuth (Headless Mode)
 * **Headless Mode for Custom UI**
 *
 * After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to
 * your `redirect_url` with query params including `tempToken`, `userProfile`, and `publicProfiles`.
 *
 * If you want to build your own fully-branded profile selector (instead of Late's hosted UI), call this
 * endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your
 * UI and call `POST /v1/connect/snapchat/select-profile` to save the selection.
 *
 * **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL.
 *
 */
export const listSnapchatProfiles = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListSnapchatProfilesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListSnapchatProfilesResponse, ListSnapchatProfilesError, ThrowOnError>({
        ...options,
        url: '/v1/connect/snapchat/select-profile'
    });
};

/**
 * Select a Snapchat Public Profile to complete the connection (Headless Mode)
 * **Complete the Snapchat Connection Flow**
 *
 * After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection.
 * Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 * After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to
 * your `redirect_url` with query params including:
 * - `tempToken` - Temporary access token
 * - `userProfile` - URL-encoded JSON with user info
 * - `publicProfiles` - URL-encoded JSON array of available public profiles
 * - `connect_token` - Short-lived token for API authentication
 * - `platform=snapchat`
 * - `step=select_public_profile`
 *
 * Parse `publicProfiles` to build your custom selector UI, then call this endpoint with the selected profile.
 *
 */
export const selectSnapchatProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectSnapchatProfileData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectSnapchatProfileResponse, SelectSnapchatProfileError, ThrowOnError>({
        ...options,
        url: '/v1/connect/snapchat/select-profile'
    });
};

/**
 * Connect Bluesky using app password
 * Connect a Bluesky account using identifier (handle or email) and an app password.
 *
 * To get your userId for the state parameter, call `GET /v1/users` - the response includes a `currentUserId` field.
 *
 */
export const connectBlueskyCredentials = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ConnectBlueskyCredentialsData, ThrowOnError>) => {
    return (options?.client ?? client).post<ConnectBlueskyCredentialsResponse, ConnectBlueskyCredentialsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/bluesky/credentials'
    });
};

/**
 * Generate Telegram access code
 * Generate a unique access code for connecting a Telegram channel or group.
 *
 * **Connection Flow:**
 * 1. Call this endpoint to get an access code (valid for 15 minutes)
 * 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group
 * 3. Open a private chat with the bot
 * 4. Send: `{CODE} @yourchannel` (e.g., `LATE-ABC123 @mychannel`)
 * 5. Poll `PATCH /v1/connect/telegram?code={CODE}` to check connection status
 *
 * **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code.
 *
 */
export const getTelegramConnectStatus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetTelegramConnectStatusData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTelegramConnectStatusResponse, GetTelegramConnectStatusError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * Direct Telegram connection (power users)
 * Connect a Telegram channel/group directly using the chat ID.
 *
 * This is an alternative to the access code flow for power users who know their Telegram chat ID.
 * The bot must already be added as an administrator in the channel/group.
 *
 */
export const initiateTelegramConnect = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<InitiateTelegramConnectData, ThrowOnError>) => {
    return (options?.client ?? client).post<InitiateTelegramConnectResponse, InitiateTelegramConnectError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * Check Telegram connection status
 * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.
 *
 * **Recommended polling interval:** 3 seconds
 *
 * **Status values:**
 * - `pending`: Code is valid, waiting for user to complete connection
 * - `connected`: Connection successful - channel/group is now linked
 * - `expired`: Code has expired, generate a new one
 *
 */
export const completeTelegramConnect = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CompleteTelegramConnectData, ThrowOnError>) => {
    return (options?.client ?? client).patch<CompleteTelegramConnectResponse, CompleteTelegramConnectError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * List available Facebook pages for a connected account
 * Returns all Facebook pages the connected account has access to, including the currently selected page.
 */
export const getFacebookPages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetFacebookPagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFacebookPagesResponse, GetFacebookPagesError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/facebook-page'
    });
};

/**
 * Update selected Facebook page for a connected account
 */
export const updateFacebookPage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateFacebookPageData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateFacebookPageResponse, UpdateFacebookPageError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/facebook-page'
    });
};

/**
 * Get available LinkedIn organizations for a connected account
 */
export const getLinkedInOrganizations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInOrganizationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInOrganizationsResponse, GetLinkedInOrganizationsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-organizations'
    });
};

/**
 * Get aggregate analytics for a LinkedIn personal account
 * Returns aggregate analytics across ALL posts for a LinkedIn personal account.
 * Uses LinkedIn's `memberCreatorPostAnalytics` API with `q=me` finder.
 *
 * **Important:** This endpoint only works for LinkedIn **personal** accounts. Organization accounts should use the standard `/v1/analytics` endpoint for per-post analytics.
 *
 * **Required Scope:** `r_member_postAnalytics`
 *
 * If the connected account doesn't have this scope, you'll receive a 403 error with instructions to reconnect.
 *
 * **Aggregation Options:**
 * - `TOTAL` (default): Returns lifetime totals for all metrics
 * - `DAILY`: Returns daily breakdown of metrics over time
 *
 * **Available Metrics:**
 * - `IMPRESSION`: Number of times posts were displayed
 * - `MEMBERS_REACHED`: Unique members who saw posts (NOT available with DAILY aggregation)
 * - `REACTION`: Total reactions (likes, celebrates, etc.)
 * - `COMMENT`: Total comments
 * - `RESHARE`: Total reshares/reposts
 *
 * **Date Range Filtering:**
 * Use `startDate` and `endDate` parameters to filter analytics to a specific time period.
 * If omitted, returns lifetime analytics.
 *
 * **LinkedIn API Limitation:** The combination of `MEMBERS_REACHED` + `DAILY` aggregation is not supported by LinkedIn's API.
 *
 */
export const getLinkedInAggregateAnalytics = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInAggregateAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInAggregateAnalyticsResponse, GetLinkedInAggregateAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-aggregate-analytics'
    });
};

/**
 * Get analytics for a specific LinkedIn post by URN
 * Returns analytics for a specific LinkedIn post using its URN.
 * Works for both personal and organization accounts.
 *
 * This is useful for fetching analytics of posts that weren't published through Late,
 * as long as you have the post URN.
 *
 * **For Personal Accounts:**
 * - Uses `memberCreatorPostAnalytics` API + `memberCreatorVideoAnalytics` for video posts
 * - Requires `r_member_postAnalytics` scope
 * - Available metrics: impressions, reach, likes, comments, shares, video views (video posts only)
 * - **Clicks are NOT available** for personal accounts
 *
 * **For Organization Accounts:**
 * - Uses `organizationalEntityShareStatistics` API + `videoAnalytics` for video posts
 * - Requires `r_organization_social` scope
 * - Available metrics: impressions, reach, clicks, likes, comments, shares, video views (video posts only), engagement rate
 *
 */
export const getLinkedInPostAnalytics = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInPostAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInPostAnalyticsResponse, GetLinkedInPostAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-post-analytics'
    });
};

/**
 * Switch LinkedIn account type (personal/organization)
 */
export const updateLinkedInOrganization = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateLinkedInOrganizationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateLinkedInOrganizationResponse, UpdateLinkedInOrganizationError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-organization'
    });
};

/**
 * Resolve a LinkedIn profile or company URL to a URN for @mentions
 * Converts a LinkedIn profile URL (person) or company page URL (organization) to a URN that can be used to @mention them in posts.
 *
 * **Supports both:**
 * - **Person mentions:** `linkedin.com/in/username` or just `username`
 * - **Organization mentions:** `linkedin.com/company/company-name` or `company/company-name`
 *
 * **⚠️ Organization Admin Required for Person Mentions Only:**
 * Person mentions require the connected LinkedIn account to have admin access to at least one LinkedIn Organization (Company Page).
 * Organization mentions do NOT have this requirement - any LinkedIn account can tag companies.
 *
 * **IMPORTANT - Display Name Requirement:**
 * For **person mentions** to be clickable, the display name must **exactly match** what appears on their LinkedIn profile.
 * - Organization mentions automatically retrieve the company name from LinkedIn API
 * - Person mentions require the exact name, so provide the `displayName` parameter
 *
 * **Mention Format:**
 * Use the returned `mentionFormat` value directly in your post content:
 * ```
 * Great insights from @[Miquel Palet](urn:li:person:4qj5ox-agD) on this topic!
 * Excited to partner with @[Microsoft](urn:li:organization:1035)!
 * ```
 *
 */
export const getLinkedInMentions = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInMentionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInMentionsResponse, GetLinkedInMentionsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-mentions'
    });
};

/**
 * List Pinterest boards for a connected account
 */
export const getPinterestBoards = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPinterestBoardsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPinterestBoardsResponse, GetPinterestBoardsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/pinterest-boards'
    });
};

/**
 * Set default Pinterest board on the connection
 */
export const updatePinterestBoards = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdatePinterestBoardsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdatePinterestBoardsResponse, UpdatePinterestBoardsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/pinterest-boards'
    });
};

/**
 * List available Google Business Profile locations for a connected account
 * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
 */
export const getGmbLocations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGmbLocationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGmbLocationsResponse, GetGmbLocationsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-locations'
    });
};

/**
 * Update selected Google Business Profile location for a connected account
 */
export const updateGmbLocation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGmbLocationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGmbLocationResponse, UpdateGmbLocationError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-locations'
    });
};

/**
 * List Reddit subreddits for a connected account
 */
export const getRedditSubreddits = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetRedditSubredditsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRedditSubredditsResponse, GetRedditSubredditsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/reddit-subreddits'
    });
};

/**
 * Set default subreddit on the connection
 */
export const updateRedditSubreddits = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateRedditSubredditsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateRedditSubredditsResponse, UpdateRedditSubredditsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/reddit-subreddits'
    });
};

/**
 * Get queue schedules for a profile
 * Retrieve queue schedules for a profile. Each profile can have multiple queues.
 * - Without `all=true`: Returns the default queue (or specific queue if queueId provided)
 * - With `all=true`: Returns all queues for the profile
 *
 */
export const listQueueSlots = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListQueueSlotsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListQueueSlotsResponse, ListQueueSlotsError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Create a new queue for a profile
 * Create an additional queue for a profile. The first queue created becomes the default.
 * Subsequent queues are non-default unless explicitly set.
 *
 */
export const createQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateQueueSlotResponse, CreateQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Create or update a queue schedule
 * Create a new queue or update an existing one.
 * - Without queueId: Creates or updates the default queue
 * - With queueId: Updates the specific queue
 * - With setAsDefault=true: Makes this queue the default for the profile
 *
 */
export const updateQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateQueueSlotResponse, UpdateQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Delete a queue schedule
 * Delete a queue from a profile. Requires queueId to specify which queue to delete.
 * If deleting the default queue, another queue will be promoted to default.
 *
 */
export const deleteQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteQueueSlotResponse, DeleteQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Preview upcoming queue slots for a profile
 */
export const previewQueue = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<PreviewQueueData, ThrowOnError>) => {
    return (options?.client ?? client).get<PreviewQueueResponse, PreviewQueueError, ThrowOnError>({
        ...options,
        url: '/v1/queue/preview'
    });
};

/**
 * Preview the next available queue slot (informational only)
 * Returns the next available queue slot for preview/informational purposes.
 *
 * **Important: To schedule a post to the queue, do NOT use this endpoint's response
 * with `scheduledFor`.** That creates a manual post, not a queue post.
 *
 * Instead, use `POST /v1/posts` with `queuedFromProfile` (and optionally `queueId`).
 * The system will automatically assign the next available slot with proper locking
 * to prevent race conditions.
 *
 * This endpoint is useful for:
 * - Showing users when their next post will go out before they commit
 * - Debugging/verifying queue configuration
 * - Building UI previews
 *
 * If no queueId is specified, uses the profile's default queue.
 *
 */
export const getNextQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetNextQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetNextQueueSlotResponse, GetNextQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/next-slot'
    });
};

/**
 * List all webhooks
 * Retrieve all configured webhooks for the authenticated user. Supports up to 10 webhooks per user.
 */
export const getWebhookSettings = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebhookSettingsResponse, GetWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Create a new webhook
 * Create a new webhook configuration. Maximum 10 webhooks per user.
 *
 * **Note:** Webhooks are automatically disabled after 10 consecutive delivery failures.
 *
 */
export const createWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateWebhookSettingsResponse, CreateWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Update a webhook
 * Update an existing webhook configuration. All fields except `_id` are optional - only provided fields will be updated.
 *
 * **Note:** Webhooks are automatically disabled after 10 consecutive delivery failures.
 *
 */
export const updateWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateWebhookSettingsResponse, UpdateWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Delete a webhook
 * Permanently delete a webhook configuration.
 */
export const deleteWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteWebhookSettingsResponse, DeleteWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Send test webhook
 * Send a test webhook to verify your endpoint is configured correctly.
 * The test payload includes `event: "webhook.test"` to distinguish it from real events.
 *
 */
export const testWebhook = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<TestWebhookData, ThrowOnError>) => {
    return (options?.client ?? client).post<TestWebhookResponse, TestWebhookError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/test'
    });
};

/**
 * Get webhook delivery logs
 * Retrieve webhook delivery history. Logs are automatically deleted after 7 days.
 *
 */
export const getWebhookLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetWebhookLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebhookLogsResponse, GetWebhookLogsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/logs'
    });
};

/**
 * Get publishing logs
 * Retrieve publishing logs for all posts. Logs show detailed information about each
 * publishing attempt including API requests, responses, and timing data.
 *
 * **Filtering:**
 * - Filter by status (success, failed, pending, skipped)
 * - Filter by platform (instagram, twitter, linkedin, etc.)
 * - Filter by action (publish, retry, rate_limit_pause, etc.)
 *
 * **Retention:** Logs are automatically deleted after 7 days.
 *
 */
export const listLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListLogsResponse, ListLogsError, ThrowOnError>({
        ...options,
        url: '/v1/logs'
    });
};

/**
 * Get a single log entry
 * Retrieve detailed information about a specific log entry, including full request
 * and response bodies for debugging.
 *
 */
export const getLog = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLogData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLogResponse, GetLogError, ThrowOnError>({
        ...options,
        url: '/v1/logs/{logId}'
    });
};

/**
 * Get logs for a specific post
 * Retrieve all publishing logs for a specific post. Shows the complete history
 * of publishing attempts for that post across all platforms.
 *
 */
export const getPostLogs = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPostLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPostLogsResponse, GetPostLogsError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}/logs'
    });
};

/**
 * List conversations across all accounts
 * Fetch conversations (DMs) from all connected messaging accounts in a single API call.
 * Supports filtering by profile and platform. Results are aggregated and deduplicated.
 *
 * **Supported platforms:** Facebook, Instagram, Twitter/X, Bluesky, Reddit, Telegram
 *
 */
export const listInboxConversations = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxConversationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxConversationsResponse, ListInboxConversationsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations'
    });
};

/**
 * Get conversation details
 * Retrieve details and metadata for a specific conversation. Requires accountId query parameter.
 */
export const getInboxConversation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxConversationData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxConversationResponse, GetInboxConversationError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}'
    });
};

/**
 * Update conversation status
 * Archive or activate a conversation. Requires accountId in request body.
 */
export const updateInboxConversation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateInboxConversationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateInboxConversationResponse, UpdateInboxConversationError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}'
    });
};

/**
 * Get messages in a conversation
 * Fetch messages for a specific conversation. Requires accountId query parameter.
 */
export const getInboxConversationMessages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxConversationMessagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxConversationMessagesResponse, GetInboxConversationMessagesError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}/messages'
    });
};

/**
 * Send a message
 * Send a message in a conversation. Requires accountId in request body.
 *
 * **Attachment support by platform:**
 * - Telegram: Images, videos, documents (up to 50MB)
 * - Facebook Messenger: Images, videos, audio, files
 * - Twitter/X: Images, videos (requires media upload)
 * - Instagram: Not supported (API limitation)
 * - Bluesky: Not supported (API limitation)
 * - Reddit: Not supported (API limitation)
 *
 */
export const sendInboxMessage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SendInboxMessageData, ThrowOnError>) => {
    return (options?.client ?? client).post<SendInboxMessageResponse, SendInboxMessageError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}/messages'
    });
};

/**
 * List posts with comments across all accounts
 * Fetch posts with their comment counts from all connected accounts.
 * Aggregates data from multiple accounts in a single API call.
 *
 * **Supported platforms:** Facebook, Instagram, Twitter/X, Bluesky, Threads, YouTube, LinkedIn, Reddit, TikTok (write-only)
 *
 */
export const listInboxComments = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxCommentsResponse, ListInboxCommentsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments'
    });
};

/**
 * Get comments for a post
 * Fetch comments for a specific post. Requires accountId query parameter.
 */
export const getInboxPostComments = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxPostCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxPostCommentsResponse, GetInboxPostCommentsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Reply to a post or comment
 * Post a reply to a post or specific comment. Requires accountId in request body.
 */
export const replyToInboxPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ReplyToInboxPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ReplyToInboxPostResponse, ReplyToInboxPostError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Delete a comment
 * Delete a comment on a post. Supported by Facebook, Instagram, Bluesky, Reddit, YouTube, LinkedIn, and TikTok.
 * Requires accountId and commentId query parameters.
 *
 */
export const deleteInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteInboxCommentResponse, DeleteInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Hide a comment
 * Hide a comment on a post. Supported by Facebook, Instagram, and Threads.
 * Hidden comments are only visible to the commenter and page admin.
 *
 */
export const hideInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<HideInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<HideInboxCommentResponse, HideInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/hide'
    });
};

/**
 * Unhide a comment
 * Unhide a previously hidden comment. Supported by Facebook, Instagram, and Threads.
 *
 */
export const unhideInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UnhideInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnhideInboxCommentResponse, UnhideInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/hide'
    });
};

/**
 * Like a comment
 * Like or upvote a comment on a post.
 *
 * **Supported platforms:** Facebook, Twitter/X, Bluesky, Reddit
 *
 * For Bluesky, the `cid` (content identifier) is required in the request body.
 *
 */
export const likeInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<LikeInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<LikeInboxCommentResponse, LikeInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/like'
    });
};

/**
 * Unlike a comment
 * Remove a like from a comment.
 *
 * **Supported platforms:** Facebook, Twitter/X, Bluesky, Reddit
 *
 * For Bluesky, the `likeUri` query parameter is required.
 *
 */
export const unlikeInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UnlikeInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnlikeInboxCommentResponse, UnlikeInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/like'
    });
};

/**
 * Send private reply to comment author
 * Send a private direct message to the author of a comment on your post.
 * This is useful for handling customer inquiries or sensitive matters privately.
 *
 * **Supported platforms:** Instagram only
 *
 * **Limitations:**
 * - Instagram only allows ONE private reply per comment
 * - Must be sent within 7 days of the comment being posted
 * - Only works for comments on posts owned by the connected account
 * - Message goes to the user's Inbox (if they follow you) or Message Requests (if they don't)
 * - Requires `instagram_business_manage_messages` permission (already included in Late's OAuth)
 *
 * **Note:** This does not create a conversation thread until the user replies back.
 *
 */
export const sendPrivateReplyToComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SendPrivateReplyToCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<SendPrivateReplyToCommentResponse, SendPrivateReplyToCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/private-reply'
    });
};

/**
 * List reviews across all accounts
 * Fetch reviews from all connected Facebook Pages and Google Business accounts.
 * Aggregates data with filtering and sorting options.
 *
 * **Supported platforms:** Facebook, Google Business
 *
 */
export const listInboxReviews = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxReviewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxReviewsResponse, ListInboxReviewsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews'
    });
};

/**
 * Reply to a review
 * Post a reply to a review. Requires accountId in request body.
 */
export const replyToInboxReview = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ReplyToInboxReviewData, ThrowOnError>) => {
    return (options?.client ?? client).post<ReplyToInboxReviewResponse, ReplyToInboxReviewError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews/{reviewId}/reply'
    });
};

/**
 * Delete a review reply
 * Delete a reply to a review (Google Business only). Requires accountId in request body.
 */
export const deleteInboxReviewReply = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteInboxReviewReplyData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteInboxReviewReplyResponse, DeleteInboxReviewReplyError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews/{reviewId}/reply'
    });
};