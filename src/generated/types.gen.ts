// This file is auto-generated by @hey-api/openapi-ts

export type AccountGetResponse = {
    account?: SocialAccount;
};

export type AccountsListResponse = {
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
};

export type AccountWithFollowerStats = SocialAccount & {
    profilePicture?: string;
    /**
     * Current follower count
     */
    currentFollowers?: number;
    lastUpdated?: string;
    /**
     * Follower change over period
     */
    growth?: number;
    /**
     * Percentage growth
     */
    growthPercentage?: number;
    /**
     * Number of historical snapshots
     */
    dataPoints?: number;
};

export type AnalyticsListResponse = {
    overview?: AnalyticsOverview;
    posts?: Array<{
        _id?: string;
        content?: string;
        scheduledFor?: string;
        publishedAt?: string;
        status?: string;
        analytics?: PostAnalytics;
        platforms?: Array<PlatformAnalytics>;
        platform?: string;
        platformPostUrl?: string;
        isExternal?: boolean;
        thumbnailUrl?: string;
        mediaType?: 'image' | 'video' | 'gif' | 'document';
        mediaItems?: Array<MediaItem>;
    }>;
    pagination?: Pagination;
    /**
     * Connected social accounts (followerCount and followersLastUpdated only included if user has analytics add-on)
     */
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
};

export type AnalyticsOverview = {
    totalPosts?: number;
    publishedPosts?: number;
    scheduledPosts?: number;
    lastSync?: string;
};

export type AnalyticsSinglePostResponse = {
    postId?: string;
    status?: string;
    content?: string;
    scheduledFor?: string;
    publishedAt?: string;
    analytics?: PostAnalytics;
    platformAnalytics?: Array<PlatformAnalytics>;
    platform?: string;
    platformPostUrl?: string;
    isExternal?: boolean;
};

export type ApiKey = {
    id?: string;
    name?: string;
    keyPreview?: string;
    expiresAt?: string;
    createdAt?: string;
    /**
     * Returned only once, on creation
     */
    key?: string;
};

export type CaptionResponse = {
    caption?: string;
};

export type DownloadFormat = {
    formatId?: string;
    ext?: string;
    resolution?: string;
    filesize?: number;
    quality?: string;
};

export type DownloadResponse = {
    url?: string;
    title?: string;
    thumbnail?: string;
    duration?: number;
    formats?: Array<DownloadFormat>;
};

export type ErrorResponse = {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
};

/**
 * Constraints:
 * - Posts cannot mix videos and images.
 * - Multiple images supported via attached_media (up to 10 images for feed posts).
 * - Multiple videos in the same post are not supported.
 * - Stories require media (single image or video); text captions are not displayed with stories.
 * - Stories are ephemeral (disappear after 24 hours).
 * - Use pageId to post to multiple pages from the same account connection.
 *
 */
export type FacebookPlatformData = {
    /**
     * Set to 'story' to publish as a Facebook Page Story (24-hour ephemeral content). Requires media.
     */
    contentType?: 'story';
    /**
     * Optional first comment to post immediately after publishing (feed posts only, not stories)
     */
    firstComment?: string;
    /**
     * Target Facebook Page ID for multi-page posting.
     * If omitted, uses the selected/default page on the connection.
     * Use GET /api/v1/accounts/{id}/facebook-page to list available pages.
     *
     */
    pageId?: string;
};

/**
 * Set to 'story' to publish as a Facebook Page Story (24-hour ephemeral content). Requires media.
 */
export type contentType = 'story';

export type FollowerStatsResponse = {
    accounts?: Array<AccountWithFollowerStats>;
    dateRange?: {
        from?: string;
        to?: string;
    };
    aggregation?: 'daily' | 'weekly' | 'monthly';
};

export type aggregation = 'daily' | 'weekly' | 'monthly';

export type FoodMenu = {
    labels: Array<FoodMenuLabel>;
    sections?: Array<FoodMenuSection>;
    /**
     * Cuisine types (e.g. AMERICAN, ITALIAN, JAPANESE)
     */
    cuisines?: Array<(string)>;
    /**
     * URL of the original menu source
     */
    sourceUrl?: string;
};

export type FoodMenuItem = {
    labels: Array<FoodMenuLabel>;
    attributes?: FoodMenuItemAttributes;
    /**
     * Item variants/options (e.g. sizes, preparations)
     */
    options?: Array<{
        labels?: Array<FoodMenuLabel>;
        attributes?: FoodMenuItemAttributes;
    }>;
};

export type FoodMenuItemAttributes = {
    price?: Money;
    /**
     * Spiciness level (e.g. MILD, MEDIUM, HOT)
     */
    spiciness?: string;
    /**
     * Allergens (e.g. DAIRY, GLUTEN, SHELLFISH)
     */
    allergen?: Array<(string)>;
    /**
     * Dietary labels (e.g. VEGETARIAN, VEGAN, GLUTEN_FREE)
     */
    dietaryRestriction?: Array<(string)>;
    /**
     * Number of people the item serves
     */
    servesNumPeople?: number;
    /**
     * Preparation methods (e.g. GRILLED, FRIED)
     */
    preparationMethods?: Array<(string)>;
    /**
     * Media references for item photos
     */
    mediaKeys?: Array<(string)>;
};

export type FoodMenuLabel = {
    /**
     * Display name of the item/section/menu
     */
    displayName: string;
    /**
     * Optional description
     */
    description?: string;
    /**
     * BCP-47 language code (e.g. en, es)
     */
    languageCode?: string;
};

export type FoodMenuSection = {
    labels: Array<FoodMenuLabel>;
    items?: Array<FoodMenuItem>;
};

/**
 * Google Business Profile post settings:
 * - Posts support text content and a single image (no videos)
 * - Images must be publicly accessible URLs
 * - Call-to-action buttons drive user engagement
 * - Posts appear on your Google Business Profile and in Google Search/Maps
 * - Use locationId to post to multiple locations from the same account connection
 *
 */
export type GoogleBusinessPlatformData = {
    /**
     * Target Google Business location ID for multi-location posting.
     * Format: "locations/123456789"
     * If omitted, uses the selected/default location on the connection.
     * Use GET /api/v1/accounts/{id}/gmb-locations to list available locations.
     *
     */
    locationId?: string;
    /**
     * Optional call-to-action button displayed on the post
     */
    callToAction?: {
        /**
         * Button action type:
         * - LEARN_MORE: Link to more information
         * - BOOK: Booking/reservation link
         * - ORDER: Online ordering link
         * - SHOP: E-commerce/shopping link
         * - SIGN_UP: Registration/signup link
         * - CALL: Phone call action
         *
         */
        type: 'LEARN_MORE' | 'BOOK' | 'ORDER' | 'SHOP' | 'SIGN_UP' | 'CALL';
        /**
         * Destination URL for the CTA button (required when callToAction is provided)
         */
        url: string;
    };
};

/**
 * Button action type:
 * - LEARN_MORE: Link to more information
 * - BOOK: Booking/reservation link
 * - ORDER: Online ordering link
 * - SHOP: E-commerce/shopping link
 * - SIGN_UP: Registration/signup link
 * - CALL: Phone call action
 *
 */
export type type = 'LEARN_MORE' | 'BOOK' | 'ORDER' | 'SHOP' | 'SIGN_UP' | 'CALL';

export type HashtagCheckResponse = {
    hashtags?: Array<HashtagInfo>;
};

export type HashtagInfo = {
    hashtag?: string;
    status?: 'safe' | 'banned' | 'restricted' | 'unknown';
    postCount?: number;
};

export type status = 'safe' | 'banned' | 'restricted' | 'unknown';

/**
 * Constraints:
 * - Feed posts require images with aspect ratio between 0.8 (4:5 portrait) and 1.91 (1.91:1 landscape).
 * - Images outside this range (e.g., 9:16 Stories/TikTok format) must use contentType 'story'.
 * - Validation happens at post creation; invalid images are rejected immediately with helpful error messages.
 * - Carousels support up to 10 media items.
 * - Stories require media; no captions are published with Stories.
 * - User tags: coordinates range from 0.0 to 1.0 representing position from top-left corner. Tagged users receive notifications.
 *
 * **Automatic Compression (similar to Bluesky):**
 * - All images (story, post, carousel, thumbnails) exceeding 8 MB are automatically compressed using quality reduction and resizing.
 * - Story videos exceeding 100 MB are automatically compressed.
 * - Reel videos exceeding 300 MB are automatically compressed.
 * - Compression uses Sharp (images) and FFmpeg (videos) to maintain quality while meeting size limits.
 * - Original files are preserved; compressed versions are uploaded to blob storage automatically.
 *
 */
export type InstagramPlatformData = {
    /**
     * Set to 'story' to publish as a Story. Default posts become Reels or feed depending on media.
     */
    contentType?: 'story';
    /**
     * For Reels only. When true (default), the Reel appears on both the Reels tab and your main profile feed. Set to false to post to the Reels tab only.
     */
    shareToFeed?: boolean;
    /**
     * Up to 3 Instagram usernames to invite as collaborators (feed/Reels only)
     */
    collaborators?: Array<(string)>;
    /**
     * Optional first comment to add after the post is created (not applied to Stories)
     */
    firstComment?: string;
    /**
     * Trial Reels configuration. Trial reels are only shared to non-followers initially.
     * They can later be "graduated" (converted to regular reels visible to followers)
     * either manually in the Instagram app or automatically based on performance.
     * Only applies to Reels (video posts).
     *
     */
    trialParams?: {
        /**
         * The graduation strategy specifies when a trial reel becomes a regular reel:
         * - MANUAL: The trial reel can only be manually graduated from the native Instagram app.
         * - SS_PERFORMANCE: The trial reel will be automatically graduated if it performs well with non-followers.
         *
         */
        graduationStrategy?: 'MANUAL' | 'SS_PERFORMANCE';
    };
    /**
     * Tag Instagram users in photos by username and position coordinates. Only works for single image posts and the first image of carousel posts. Not supported for stories or videos.
     */
    userTags?: Array<{
        /**
         * Instagram username (@ symbol is optional and will be removed automatically)
         */
        username: string;
        /**
         * X coordinate position from left edge (0.0 = left, 0.5 = center, 1.0 = right)
         */
        x: number;
        /**
         * Y coordinate position from top edge (0.0 = top, 0.5 = center, 1.0 = bottom)
         */
        y: number;
    }>;
    /**
     * Custom name for the original audio in Reels. Replaces the default "Original Audio" label.
     * Only applies to Reels (video posts). Can only be set once - either during creation or
     * later from the Instagram audio page in the app.
     *
     */
    audioName?: string;
    /**
     * Millisecond offset from the start of the video to use as the Reel thumbnail.
     * Only applies to Reels (video posts). If a custom thumbnail URL (instagramThumbnail
     * in mediaItems) is provided, it takes priority and this offset is ignored.
     * Defaults to 0 (first frame).
     *
     */
    thumbOffset?: number;
};

/**
 * The graduation strategy specifies when a trial reel becomes a regular reel:
 * - MANUAL: The trial reel can only be manually graduated from the native Instagram app.
 * - SS_PERFORMANCE: The trial reel will be automatically graduated if it performs well with non-followers.
 *
 */
export type graduationStrategy = 'MANUAL' | 'SS_PERFORMANCE';

/**
 * Response for DAILY aggregation (time series breakdown)
 */
export type LinkedInAggregateAnalyticsDailyResponse = {
    accountId?: string;
    platform?: string;
    accountType?: string;
    username?: string;
    aggregation?: 'DAILY';
    dateRange?: {
        startDate?: string;
        endDate?: string;
    } | null;
    /**
     * Daily breakdown of each metric. Each metric contains an array of date/count pairs.
     * Note: 'reach' (MEMBERS_REACHED) is not available with DAILY aggregation per LinkedIn API limitations.
     *
     */
    analytics?: {
        impressions?: Array<{
            date?: string;
            count?: number;
        }>;
        reactions?: Array<{
            date?: string;
            count?: number;
        }>;
        comments?: Array<{
            date?: string;
            count?: number;
        }>;
        shares?: Array<{
            date?: string;
            count?: number;
        }>;
    };
    /**
     * Metrics that were skipped due to API limitations
     */
    skippedMetrics?: Array<(string)>;
    note?: string;
    lastUpdated?: string;
};

export type aggregation2 = 'DAILY';

/**
 * Response for TOTAL aggregation (lifetime totals)
 */
export type LinkedInAggregateAnalyticsTotalResponse = {
    accountId?: string;
    platform?: string;
    accountType?: string;
    username?: string;
    aggregation?: 'TOTAL';
    dateRange?: {
        startDate?: string;
        endDate?: string;
    } | null;
    analytics?: {
        /**
         * Total impressions across all posts
         */
        impressions?: number;
        /**
         * Unique members reached across all posts
         */
        reach?: number;
        /**
         * Total reactions across all posts
         */
        reactions?: number;
        /**
         * Total comments across all posts
         */
        comments?: number;
        /**
         * Total reshares across all posts
         */
        shares?: number;
        /**
         * Overall engagement rate as percentage
         */
        engagementRate?: number;
    };
    note?: string;
    lastUpdated?: string;
};

export type aggregation3 = 'TOTAL';

/**
 * Constraints:
 * - Multi-image posts support up to 20 images.
 * - Multi-video posts are not supported.
 * - Single PDF document posts are supported (max 100MB, ~300 pages). Documents cannot be mixed with other media.
 * - Post ID is returned in the x-restli-id response header.
 * - Link previews are automatically generated for URLs when no media is attached (can be disabled with disableLinkPreview).
 * - Use organizationUrn to post to multiple organizations from the same account connection.
 *
 */
export type LinkedInPlatformData = {
    /**
     * Target LinkedIn Organization URN for multi-organization posting.
     * Format: "urn:li:organization:123456789"
     * If omitted, uses the selected/default organization on the connection.
     * Use GET /api/v1/accounts/{id}/linkedin-organizations to list available organizations.
     *
     */
    organizationUrn?: string;
    /**
     * Optional first comment to add after the post is created
     */
    firstComment?: string;
    /**
     * Set to true to disable automatic link previews for URLs in the post content (default is false)
     */
    disableLinkPreview?: boolean;
};

/**
 * Media referenced in posts. URLs must be publicly reachable over HTTPS by the destination platforms.
 * When using third‑party storage, ensure signed links remain valid until upload completes.
 *
 * **Uploading Media:**
 * Use `POST /v1/media/presign` to get a presigned URL, then upload your file directly to cloud storage.
 * Supports files up to 5GB. See the `/v1/media/presign` endpoint documentation for details.
 *
 * **Automatic Media Compression:**
 * Late automatically compresses media that exceeds platform limits, so you don't need to worry about file size restrictions. Compression happens server-side during publishing.
 *
 * **Image compression by platform:**
 * - Twitter/X: >5 MB
 * - Instagram: >8 MB
 * - Threads: >8 MB
 * - Facebook: >10 MB
 * - LinkedIn: >8 MB
 * - TikTok: >20 MB
 * - Pinterest: >32 MB
 * - Reddit: >20 MB
 * - Snapchat: >20 MB
 * - Telegram: >10 MB
 * - Bluesky: >1 MB
 * - YouTube (thumbnails): >2 MB
 * - Google Business: >5 MB
 *
 * **Video compression by platform:**
 * - Twitter/X: >512 MB
 * - Instagram Stories: >100 MB
 * - Instagram Reels: >300 MB
 * - Facebook: >4 GB
 * - LinkedIn: >5 GB
 * - TikTok: >4 GB
 * - Pinterest: >2 GB
 * - Snapchat: >500 MB
 * - Telegram: >50 MB
 *
 * Note: Videos larger than 200 MB may not be compressed due to server timeout constraints. For best results, compress very large videos before uploading.
 *
 */
export type MediaItem = {
    type?: 'image' | 'video' | 'gif' | 'document';
    url?: string;
    filename?: string;
    /**
     * Optional file size in bytes
     */
    size?: number;
    /**
     * Optional MIME type (e.g. image/jpeg, video/mp4)
     */
    mimeType?: string;
    /**
     * Optional thumbnail image URL for videos
     */
    thumbnail?: string;
    /**
     * Optional custom cover image URL for Instagram Reels
     */
    instagramThumbnail?: string;
    /**
     * Internal flag indicating the image was resized for TikTok
     */
    tiktokProcessed?: boolean;
};

export type type2 = 'image' | 'video' | 'gif' | 'document';

export type MediaUploadResponse = {
    files?: Array<UploadedFile>;
};

export type Money = {
    /**
     * ISO 4217 currency code (e.g. USD, EUR)
     */
    currencyCode: string;
    /**
     * Whole units of the amount
     */
    units: string;
    /**
     * Nano units (10^-9) of the amount
     */
    nanos?: number;
};

export type Pagination = {
    page?: number;
    limit?: number;
    total?: number;
    pages?: number;
};

/**
 * Page size
 */
export type ParameterLimitParam = number;

/**
 * Page number (1-based)
 */
export type ParameterPageParam = number;

export type PinterestPlatformData = {
    /**
     * Pin title. Defaults to first line of content or "Pin". Must be ≤ 100 characters.
     */
    title?: string;
    /**
     * Target Pinterest board ID. If omitted, the first available board is used.
     */
    boardId?: string;
    /**
     * Destination link (pin URL)
     */
    link?: string;
    /**
     * Optional cover image for video pins
     */
    coverImageUrl?: string;
    /**
     * Optional key frame time in seconds for derived video cover
     */
    coverImageKeyFrameTime?: number;
};

export type PlatformAnalytics = {
    platform?: string;
    status?: string;
    accountId?: string;
    accountUsername?: string;
    analytics?: PostAnalytics;
    accountMetrics?: {
        /**
         * Followers/fans count (e.g., Instagram, Facebook Pages, Twitter)
         */
        followers?: (number) | null;
        /**
         * Subscribers count (e.g., YouTube)
         */
        subscribers?: (number) | null;
        lastUpdated?: (string) | null;
    } | null;
};

export type PlatformTarget = {
    /**
     * Supported values: twitter, threads, instagram, youtube, facebook, linkedin, pinterest, reddit, tiktok, bluesky, googlebusiness, telegram
     */
    platform?: string;
    accountId?: (string | SocialAccount);
    customContent?: string;
    customMedia?: Array<MediaItem>;
    /**
     * Optional per-platform scheduled time override (uses post.scheduledFor when omitted)
     */
    scheduledFor?: string;
    /**
     * Platform-specific overrides and options.
     */
    platformSpecificData?: (TwitterPlatformData | ThreadsPlatformData | FacebookPlatformData | InstagramPlatformData | LinkedInPlatformData | PinterestPlatformData | YouTubePlatformData | GoogleBusinessPlatformData | TikTokPlatformData | TelegramPlatformData | SnapchatPlatformData);
    /**
     * Platform-specific status: pending, publishing, published, failed
     */
    status?: string;
    /**
     * The native post ID on the platform (populated after successful publish)
     */
    platformPostId?: string;
    /**
     * Public URL of the published post on the platform.
     * Populated after successful publish. For immediate posts (publishNow=true),
     * this is included in the response. For scheduled posts, fetch the post
     * via GET /v1/posts/{postId} after the scheduled time.
     *
     */
    platformPostUrl?: string;
    /**
     * Timestamp when the post was published to this platform
     */
    publishedAt?: string;
    /**
     * Human-readable error message when status is 'failed'.
     * Contains platform-specific error details explaining why the publish failed.
     * Examples:
     * - "Instagram access token has expired. Please reconnect your account."
     * - "Post text exceeds the 500 character limit for Threads."
     * - "You do not have enough karma to post in this subreddit."
     * - "Video is too long for Reels. Facebook Reels must be 90 seconds or less."
     *
     */
    errorMessage?: string;
    /**
     * Error category for programmatic handling:
     * - auth_expired: Token expired or revoked, account needs reconnection
     * - user_content: Content doesn't meet platform requirements (too long, wrong format, etc.)
     * - user_abuse: Rate limits, spam detection, excessive posting
     * - account_issue: Account configuration problems (missing board, inactive account)
     * - platform_rejected: Platform rules violated (banned, suspended, policy violation)
     * - platform_error: Platform-side issues (5xx errors, maintenance)
     * - system_error: Late infrastructure issues (timeouts, network errors)
     * - unknown: Unclassified error
     *
     */
    errorCategory?: 'auth_expired' | 'user_content' | 'user_abuse' | 'account_issue' | 'platform_rejected' | 'platform_error' | 'system_error' | 'unknown';
    /**
     * Who/what caused the error:
     * - user: User action required (fix content, reconnect account)
     * - platform: Platform-side issue (outage, API change)
     * - system: Late system issue (rare)
     *
     */
    errorSource?: 'user' | 'platform' | 'system';
};

/**
 * Error category for programmatic handling:
 * - auth_expired: Token expired or revoked, account needs reconnection
 * - user_content: Content doesn't meet platform requirements (too long, wrong format, etc.)
 * - user_abuse: Rate limits, spam detection, excessive posting
 * - account_issue: Account configuration problems (missing board, inactive account)
 * - platform_rejected: Platform rules violated (banned, suspended, policy violation)
 * - platform_error: Platform-side issues (5xx errors, maintenance)
 * - system_error: Late infrastructure issues (timeouts, network errors)
 * - unknown: Unclassified error
 *
 */
export type errorCategory = 'auth_expired' | 'user_content' | 'user_abuse' | 'account_issue' | 'platform_rejected' | 'platform_error' | 'system_error' | 'unknown';

/**
 * Who/what caused the error:
 * - user: User action required (fix content, reconnect account)
 * - platform: Platform-side issue (outage, API change)
 * - system: Late system issue (rare)
 *
 */
export type errorSource = 'user' | 'platform' | 'system';

export type Post = {
    _id?: string;
    userId?: (string | User);
    /**
     * YouTube: title must be ≤ 100 characters.
     *
     */
    title?: string;
    content?: string;
    mediaItems?: Array<MediaItem>;
    platforms?: Array<PlatformTarget>;
    scheduledFor?: string;
    timezone?: string;
    status?: 'draft' | 'scheduled' | 'publishing' | 'published' | 'failed' | 'partial';
    /**
     * YouTube tag constraints when targeting YouTube:
     * - No count cap; duplicates removed.
     * - Each tag must be ≤ 100 chars.
     * - Combined characters across all tags ≤ 500.
     *
     */
    tags?: Array<(string)>;
    hashtags?: Array<(string)>;
    mentions?: Array<(string)>;
    visibility?: 'public' | 'private' | 'unlisted';
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Profile ID if the post was scheduled via the queue
     */
    queuedFromProfile?: string;
    /**
     * Queue ID if the post was scheduled via a specific queue
     */
    queueId?: string;
    createdAt?: string;
    updatedAt?: string;
};

export type status2 = 'draft' | 'scheduled' | 'publishing' | 'published' | 'failed' | 'partial';

export type visibility = 'public' | 'private' | 'unlisted';

export type PostAnalytics = {
    impressions?: number;
    reach?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    /**
     * Number of saves/bookmarks (Instagram, Pinterest)
     */
    saves?: number;
    clicks?: number;
    views?: number;
    engagementRate?: number;
    lastUpdated?: string;
};

export type PostCreateResponse = {
    message?: string;
    post?: Post;
};

export type PostDeleteResponse = {
    message?: string;
};

export type PostGetResponse = {
    post?: Post;
};

/**
 * Publishing log entry showing details of a post publishing attempt
 */
export type PostLog = {
    _id?: string;
    postId?: (string | {
    _id?: string;
    content?: string;
    status?: string;
});
    userId?: string;
    profileId?: string;
    platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
    accountId?: string;
    accountUsername?: string;
    /**
     * Type of action logged:
     * - `publish` - Initial publish attempt
     * - `retry` - Retry after failure
     * - `media_upload` - Media upload step
     * - `rate_limit_pause` - Account paused due to rate limits
     * - `token_refresh` - Token was refreshed
     * - `cancelled` - Post was cancelled
     *
     */
    action?: 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled';
    status?: 'success' | 'failed' | 'pending' | 'skipped';
    /**
     * HTTP status code from platform API
     */
    statusCode?: number;
    /**
     * Platform API endpoint called
     */
    endpoint?: string;
    request?: {
        /**
         * First 200 chars of caption
         */
        contentPreview?: string;
        mediaCount?: number;
        mediaTypes?: Array<(string)>;
        /**
         * URLs of media items sent to platform
         */
        mediaUrls?: Array<(string)>;
        scheduledFor?: string;
        /**
         * Full request body JSON (max 5000 chars)
         */
        rawBody?: string;
    };
    response?: {
        /**
         * ID returned by platform on success
         */
        platformPostId?: string;
        /**
         * URL of published post
         */
        platformPostUrl?: string;
        /**
         * Error message on failure
         */
        errorMessage?: string;
        /**
         * Platform-specific error code
         */
        errorCode?: string;
        /**
         * Full response body JSON (max 5000 chars)
         */
        rawBody?: string;
    };
    /**
     * How long the operation took in milliseconds
     */
    durationMs?: number;
    /**
     * Attempt number (1 for first try, 2+ for retries)
     */
    attemptNumber?: number;
    createdAt?: string;
};

export type platform = 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';

/**
 * Type of action logged:
 * - `publish` - Initial publish attempt
 * - `retry` - Retry after failure
 * - `media_upload` - Media upload step
 * - `rate_limit_pause` - Account paused due to rate limits
 * - `token_refresh` - Token was refreshed
 * - `cancelled` - Post was cancelled
 *
 */
export type action = 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled';

export type status3 = 'success' | 'failed' | 'pending' | 'skipped';

export type PostLogDetail = PostLog & {
    /**
     * Populated post with full details
     */
    postId?: {
        _id?: string;
        content?: string;
        status?: string;
        scheduledFor?: string;
        platforms?: Array<{
            [key: string]: unknown;
        }>;
        mediaItems?: Array<{
            [key: string]: unknown;
        }>;
    };
    /**
     * Populated account reference
     */
    accountId?: {
        _id?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
    /**
     * Additional metadata (e.g., rate limit info)
     */
    metadata?: {
        [key: string]: unknown;
    };
};

export type PostRetryResponse = {
    message?: string;
    post?: Post;
};

export type PostsListResponse = {
    posts?: Array<Post>;
    pagination?: Pagination;
};

export type PostUpdateResponse = {
    message?: string;
    post?: Post;
};

export type Profile = {
    _id?: string;
    userId?: string;
    name?: string;
    description?: string;
    color?: string;
    isDefault?: boolean;
    /**
     * Only present when `includeOverLimit=true` is used. Indicates if this profile
     * exceeds the user's plan limit. Over-limit profiles cannot be used for posting
     * but can be managed (disconnected accounts, deleted).
     *
     */
    isOverLimit?: boolean;
    createdAt?: string;
};

export type ProfileCreateResponse = {
    message?: string;
    profile?: Profile;
};

export type ProfileDeleteResponse = {
    message?: string;
};

export type ProfileGetResponse = {
    profile?: Profile;
};

export type ProfilesListResponse = {
    profiles?: Array<Profile>;
};

export type ProfileUpdateResponse = {
    message?: string;
    profile?: Profile;
};

export type QueueDeleteResponse = {
    success?: boolean;
    deleted?: boolean;
};

export type QueueNextSlotResponse = {
    profileId?: string;
    nextSlot?: string;
    timezone?: string;
};

export type QueuePreviewResponse = {
    profileId?: string;
    count?: number;
    slots?: Array<(string)>;
};

export type QueueSchedule = {
    /**
     * Unique queue identifier
     */
    _id?: string;
    /**
     * Profile ID this queue belongs to
     */
    profileId?: string;
    /**
     * Queue name (e.g., "Morning Posts", "Evening Content")
     */
    name?: string;
    /**
     * IANA timezone (e.g., America/New_York)
     */
    timezone?: string;
    slots?: Array<QueueSlot>;
    /**
     * Whether the queue is active
     */
    active?: boolean;
    /**
     * Whether this is the default queue for the profile (used when no queueId specified)
     */
    isDefault?: boolean;
    createdAt?: string;
    updatedAt?: string;
};

export type QueueSlot = {
    /**
     * Day of week (0=Sunday, 6=Saturday)
     */
    dayOfWeek?: number;
    /**
     * Time in HH:mm format (24-hour)
     */
    time?: string;
};

export type QueueSlotsResponse = {
    exists?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
};

export type QueueUpdateResponse = {
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
    reshuffledCount?: number;
};

/**
 * Snapchat Public Profile API constraints:
 *
 * **General Requirements:**
 * - Snapchat requires a Public Profile to publish content
 * - Media is required for all content types (no text-only posts)
 * - Only one media item per post is supported
 * - Media is automatically encrypted using AES-256-CBC before upload
 *
 * **Content Types:**
 * - **Story** (default): Ephemeral content visible for 24 hours. No caption/text supported.
 * - **Saved Story**: Permanent story on your Public Profile. Uses post content as title (max 45 chars).
 * - **Spotlight**: Video content for Snapchat's entertainment feed. Supports description (max 160 chars) with hashtags.
 *
 * **Media Constraints:**
 * - Images: max 20 MB, JPEG/PNG format
 * - Videos: max 500 MB, MP4 format, 5-60 seconds duration, minimum 540x960px resolution
 * - Aspect ratio: 9:16 recommended
 *
 * **Analytics:**
 * - Views, screenshots, shares, unique viewers, completion rate available
 * - Analytics are fetched per content type (story/saved_story/spotlight)
 *
 */
export type SnapchatPlatformData = {
    /**
     * Type of Snapchat content to publish:
     * - `story` - Ephemeral snap visible for 24 hours (default)
     * - `saved_story` - Permanent story saved to Public Profile
     * - `spotlight` - Video posted to Spotlight (Snapchat's TikTok-like feed)
     *
     */
    contentType?: 'story' | 'saved_story' | 'spotlight';
};

/**
 * Type of Snapchat content to publish:
 * - `story` - Ephemeral snap visible for 24 hours (default)
 * - `saved_story` - Permanent story saved to Public Profile
 * - `spotlight` - Video posted to Spotlight (Snapchat's TikTok-like feed)
 *
 */
export type contentType2 = 'story' | 'saved_story' | 'spotlight';

export type SocialAccount = {
    _id?: string;
    platform?: string;
    profileId?: (string | Profile);
    username?: string;
    displayName?: string;
    /**
     * Full profile URL for the connected account. Available for all platforms:
     * - Twitter/X: https://x.com/{username}
     * - Instagram: https://instagram.com/{username}
     * - TikTok: https://tiktok.com/@{username}
     * - YouTube: https://youtube.com/@{handle} or https://youtube.com/channel/{id}
     * - LinkedIn Personal: https://www.linkedin.com/in/{vanityName}/
     * - LinkedIn Organization: https://www.linkedin.com/company/{vanityName}/
     * - Threads: https://threads.net/@{username}
     * - Pinterest: https://pinterest.com/{username}
     * - Reddit: https://reddit.com/user/{username}
     * - Bluesky: https://bsky.app/profile/{handle}
     * - Facebook: https://facebook.com/{username} or https://facebook.com/{pageId}
     * - Google Business: Google Maps URL for the business location
     *
     */
    profileUrl?: string;
    isActive?: boolean;
    /**
     * Follower count (only included if user has analytics add-on)
     */
    followersCount?: number;
    /**
     * Last time follower count was updated (only included if user has analytics add-on)
     */
    followersLastUpdated?: string;
};

/**
 * Telegram channel/group posting settings:
 * - Supports text, images (up to 10), videos (up to 10), and mixed media albums
 * - Posts to channels display the channel name and logo as author
 * - Posts to groups display the bot name (Late) as author
 * - Message IDs are returned for analytics tracking
 * - Captions support up to 1024 characters for media posts, 4096 for text-only
 *
 * **Analytics:**
 * - **Not available via API.** The Telegram Bot API does not expose message analytics (views, forwards, reactions).
 * - View counts are only visible to channel admins directly in the Telegram app.
 * - This is a Telegram platform limitation that affects all third-party tools.
 *
 */
export type TelegramPlatformData = {
    /**
     * Text formatting mode for the message (default is HTML)
     */
    parseMode?: 'HTML' | 'Markdown' | 'MarkdownV2';
    /**
     * Disable link preview generation for URLs in the message
     */
    disableWebPagePreview?: boolean;
    /**
     * Send the message silently (users will receive notification without sound)
     */
    disableNotification?: boolean;
    /**
     * Protect message content from forwarding and saving
     */
    protectContent?: boolean;
};

/**
 * Text formatting mode for the message (default is HTML)
 */
export type parseMode = 'HTML' | 'Markdown' | 'MarkdownV2';

/**
 * Constraints:
 * - Carousel posts support up to 10 images (no videos in carousels).
 * - Single posts support one image or one video.
 * - Videos must be H.264/AAC MP4 format, max 5 minutes duration.
 * - Images must be JPEG or PNG, max 8 MB each.
 * - threadItems creates a reply chain (Threads equivalent of Twitter threads).
 *
 */
export type ThreadsPlatformData = {
    /**
     * Sequence of posts in a Threads thread (root then replies in order).
     */
    threadItems?: Array<{
        content?: string;
        mediaItems?: Array<MediaItem>;
    }>;
};

/**
 * TikTok platform-specific settings for video/photo posting.
 *
 * **Constraints:**
 * - Photo carousels support up to 35 images.
 * - **Title length limits**:
 * - Videos: up to 2200 chars (full content used as title)
 * - Photos: content is automatically truncated to 90 chars for title (hashtags/URLs stripped). Use 'description' field for longer text (up to 4000 chars).
 * - privacyLevel must be chosen from creator_info.privacy_level_options (no defaulting).
 * - allowDuet and allowStitch required for videos; allowComment for all.
 * - contentPreviewConfirmed and expressConsentGiven must be true before posting.
 *
 * **Note:** Both camelCase and snake_case field names are accepted for backwards compatibility.
 * The nested `tiktokSettings` object format is also still supported but deprecated.
 *
 */
export type TikTokPlatformData = {
    /**
     * When true, Late sends the post to the TikTok Creator Inbox as a draft instead of publishing it immediately. When omitted or false, TikTok uses direct posting (live publish) as usual.
     *
     */
    draft?: boolean;
    /**
     * One of the values returned by the TikTok creator info API for the account
     */
    privacyLevel?: string;
    /**
     * Allow comments on the post
     */
    allowComment?: boolean;
    /**
     * Allow duets (required for video posts)
     */
    allowDuet?: boolean;
    /**
     * Allow stitches (required for video posts)
     */
    allowStitch?: boolean;
    /**
     * Type of commercial content disclosure
     */
    commercialContentType?: 'none' | 'brand_organic' | 'brand_content';
    /**
     * Whether the post promotes a brand partner
     */
    brandPartnerPromote?: boolean;
    /**
     * Whether the post is a brand organic post
     */
    isBrandOrganicPost?: boolean;
    /**
     * User has confirmed they previewed the content
     */
    contentPreviewConfirmed?: boolean;
    /**
     * User has given express consent for posting
     */
    expressConsentGiven?: boolean;
    /**
     * Optional override. Defaults based on provided media items.
     */
    mediaType?: 'video' | 'photo';
    /**
     * Optional for video posts. Timestamp in milliseconds to select which frame to use as thumbnail (defaults to 1000ms/1 second).
     */
    videoCoverTimestampMs?: number;
    /**
     * Optional for photo carousels. Index of image to use as cover, 0-based (defaults to 0/first image).
     */
    photoCoverIndex?: number;
    /**
     * When true, TikTok may add recommended music (photos only)
     */
    autoAddMusic?: boolean;
    /**
     * Set true to disclose AI-generated content
     */
    videoMadeWithAi?: boolean;
    /**
     * Optional long-form description for photo posts (max 4000 chars).
     * Recommended for photo posts when content exceeds 90 characters, as photo titles are automatically truncated to 90 chars (after stripping hashtags/URLs).
     *
     */
    description?: string;
};

/**
 * Type of commercial content disclosure
 */
export type commercialContentType = 'none' | 'brand_organic' | 'brand_content';

/**
 * Optional override. Defaults based on provided media items.
 */
export type mediaType = 'video' | 'photo';

/**
 * **DEPRECATED**: Use flat properties directly in TikTokPlatformData instead.
 * This nested format is supported for backwards compatibility only.
 *
 * @deprecated
 */
export type TikTokSettings = {
    privacyLevel?: string;
    allowComment?: boolean;
    allowDuet?: boolean;
    allowStitch?: boolean;
    commercialContentType?: string;
    brandPartnerPromote?: boolean;
    isBrandOrganicPost?: boolean;
    contentPreviewConfirmed?: boolean;
    expressConsentGiven?: boolean;
    mediaType?: string;
    videoCoverTimestampMs?: number;
    photoCoverIndex?: number;
    autoAddMusic?: boolean;
    videoMadeWithAi?: boolean;
    description?: string;
};

export type TranscriptResponse = {
    transcript?: string;
    segments?: Array<TranscriptSegment>;
    language?: string;
};

export type TranscriptSegment = {
    text?: string;
    start?: number;
    duration?: number;
};

export type TwitterPlatformData = {
    /**
     * Sequence of tweets in a thread. First item is the root tweet.
     */
    threadItems?: Array<{
        content?: string;
        mediaItems?: Array<MediaItem>;
    }>;
};

export type UploadedFile = {
    type?: 'image' | 'video' | 'document';
    url?: string;
    filename?: string;
    size?: number;
    mimeType?: string;
};

export type type3 = 'image' | 'video' | 'document';

export type UploadTokenResponse = {
    token?: string;
    uploadUrl?: string;
    expiresAt?: string;
    status?: 'pending' | 'completed' | 'expired';
};

export type status4 = 'pending' | 'completed' | 'expired';

export type UploadTokenStatusResponse = {
    token?: string;
    status?: 'pending' | 'completed' | 'expired';
    files?: Array<UploadedFile>;
    createdAt?: string;
    expiresAt?: string;
    completedAt?: string;
};

export type UsageStats = {
    planName?: string;
    billingPeriod?: 'monthly' | 'yearly';
    signupDate?: string;
    limits?: {
        uploads?: number;
        profiles?: number;
    };
    usage?: {
        uploads?: number;
        profiles?: number;
        lastReset?: string;
    };
};

export type billingPeriod = 'monthly' | 'yearly';

export type User = {
    _id?: string;
    email?: string;
    name?: string;
    role?: string;
    createdAt?: string;
};

export type UserGetResponse = {
    user?: User;
};

export type UsersListResponse = {
    users?: Array<User>;
};

/**
 * Individual webhook configuration for receiving real-time notifications
 */
export type Webhook = {
    /**
     * Unique webhook identifier
     */
    _id?: string;
    /**
     * Webhook name (for identification)
     */
    name?: string;
    /**
     * Webhook endpoint URL
     */
    url?: string;
    /**
     * Secret key for HMAC-SHA256 signature (not returned in responses for security)
     */
    secret?: string;
    /**
     * Events subscribed to
     */
    events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received')>;
    /**
     * Whether webhook delivery is enabled
     */
    isActive?: boolean;
    /**
     * Timestamp of last successful webhook delivery
     */
    lastFiredAt?: string;
    /**
     * Consecutive delivery failures (resets on success, webhook disabled at 10)
     */
    failureCount?: number;
    /**
     * Custom headers included in webhook requests
     */
    customHeaders?: {
        [key: string]: (string);
    };
};

/**
 * Webhook delivery log entry
 */
export type WebhookLog = {
    _id?: string;
    /**
     * ID of the webhook that was triggered
     */
    webhookId?: string;
    /**
     * Name of the webhook that was triggered
     */
    webhookName?: string;
    event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'webhook.test';
    url?: string;
    status?: 'success' | 'failed';
    /**
     * HTTP status code from webhook endpoint
     */
    statusCode?: number;
    /**
     * Payload sent to webhook endpoint
     */
    requestPayload?: {
        [key: string]: unknown;
    };
    /**
     * Response body from webhook endpoint (truncated to 10KB)
     */
    responseBody?: string;
    /**
     * Error message if delivery failed
     */
    errorMessage?: string;
    /**
     * Delivery attempt number (max 3 retries)
     */
    attemptNumber?: number;
    /**
     * Response time in milliseconds
     */
    responseTime?: number;
    createdAt?: string;
};

export type event = 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'webhook.test';

export type status5 = 'success' | 'failed';

/**
 * Webhook payload for account connected events
 */
export type WebhookPayloadAccountConnected = {
    event?: 'account.connected';
    account?: {
        /**
         * The account's unique identifier (same as used in /v1/accounts/{accountId})
         */
        accountId?: string;
        /**
         * The profile's unique identifier this account belongs to
         */
        profileId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
    timestamp?: string;
};

export type event2 = 'account.connected';

/**
 * Webhook payload for account disconnected events
 */
export type WebhookPayloadAccountDisconnected = {
    event?: 'account.disconnected';
    account?: {
        /**
         * The account's unique identifier (same as used in /v1/accounts/{accountId})
         */
        accountId?: string;
        /**
         * The profile's unique identifier this account belongs to
         */
        profileId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
        /**
         * Whether the disconnection was intentional (user action) or unintentional (token expired/revoked)
         */
        disconnectionType?: 'intentional' | 'unintentional';
        /**
         * Human-readable reason for the disconnection
         */
        reason?: string;
    };
    timestamp?: string;
};

export type event3 = 'account.disconnected';

/**
 * Whether the disconnection was intentional (user action) or unintentional (token expired/revoked)
 */
export type disconnectionType = 'intentional' | 'unintentional';

/**
 * Webhook payload for message received events (DMs from Instagram, Telegram)
 */
export type WebhookPayloadMessage = {
    event?: 'message.received';
    message?: {
        /**
         * Internal message ID
         */
        id?: string;
        /**
         * Internal conversation ID
         */
        conversationId?: string;
        platform?: 'instagram' | 'facebook' | 'telegram';
        /**
         * Platform's message ID
         */
        platformMessageId?: string;
        direction?: 'incoming';
        /**
         * Message text content
         */
        text?: (string) | null;
        attachments?: Array<{
            /**
             * Attachment type (image, video, file, sticker, audio)
             */
            type?: string;
            /**
             * Attachment URL (may expire for Meta platforms)
             */
            url?: string;
            /**
             * Additional attachment metadata
             */
            payload?: {
                [key: string]: unknown;
            };
        }>;
        sender?: {
            id?: string;
            name?: string;
            username?: string;
            picture?: string;
        };
        sentAt?: string;
        isRead?: boolean;
    };
    conversation?: {
        id?: string;
        platformConversationId?: string;
        participantId?: string;
        participantName?: string;
        participantUsername?: string;
        participantPicture?: string;
        status?: 'active' | 'archived';
    };
    account?: {
        /**
         * Social account ID
         */
        id?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
    timestamp?: string;
};

export type event4 = 'message.received';

export type platform2 = 'instagram' | 'facebook' | 'telegram';

export type direction = 'incoming';

export type status6 = 'active' | 'archived';

/**
 * Webhook payload for post events
 */
export type WebhookPayloadPost = {
    event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial';
    post?: {
        id?: string;
        content?: string;
        status?: string;
        scheduledFor?: string;
        publishedAt?: string;
        platforms?: Array<{
            platform?: string;
            status?: string;
            publishedUrl?: string;
            error?: string;
        }>;
    };
    timestamp?: string;
};

export type event5 = 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial';

export type YouTubeDailyViewsResponse = {
    success?: boolean;
    /**
     * The YouTube video ID
     */
    videoId?: string;
    dateRange?: {
        startDate?: string;
        endDate?: string;
    };
    /**
     * Sum of views across all days in the range
     */
    totalViews?: number;
    dailyViews?: Array<{
        date?: string;
        views?: number;
        estimatedMinutesWatched?: number;
        /**
         * Average view duration in seconds
         */
        averageViewDuration?: number;
        subscribersGained?: number;
        subscribersLost?: number;
        likes?: number;
        comments?: number;
        shares?: number;
    }>;
    /**
     * When the data was last synced from YouTube
     */
    lastSyncedAt?: (string) | null;
    scopeStatus?: {
        hasAnalyticsScope?: boolean;
    };
};

/**
 * YouTube video upload settings:
 * - Videos ≤ 3 minutes are automatically detected as YouTube Shorts
 * - Videos > 3 minutes become regular YouTube videos
 * - Custom thumbnails supported for regular videos (via mediaItem.thumbnail)
 * - Custom thumbnails NOT supported for Shorts via API
 * - Scheduled videos are uploaded immediately as the specified visibility and published at scheduled time
 * - Visibility defaults to "public" if not specified
 * - madeForKids defaults to false (not child-directed)
 * - Set containsSyntheticMedia: true if your video contains AI-generated content
 *
 */
export type YouTubePlatformData = {
    /**
     * Video title. Defaults to first line of content or "Untitled Video". Must be ≤ 100 characters.
     */
    title?: string;
    /**
     * Video visibility setting:
     * - public: Anyone can search for and watch (default)
     * - unlisted: Only people with the link can watch
     * - private: Only you and people you specifically share with can watch
     *
     */
    visibility?: 'public' | 'private' | 'unlisted';
    /**
     * COPPA compliance: Audience designation for the video.
     * - true: Video is made for kids (child-directed content)
     * - false: Video is NOT made for kids (default)
     *
     * This field maps to YouTube's `selfDeclaredMadeForKids` setting. Videos marked as made for kids
     * have restricted features (no comments, no notifications, limited ad targeting).
     *
     * IMPORTANT: If not specified, defaults to false. YouTube requires this to be explicitly set,
     * otherwise the video may be blocked from views until configured in YouTube Studio.
     *
     */
    madeForKids?: boolean;
    /**
     * Optional first comment to post immediately after video upload. Up to 10,000 characters (YouTube's comment limit).
     */
    firstComment?: string;
    /**
     * AI-generated content disclosure flag. Set to true if your video contains AI-generated or synthetic content
     * that could be mistaken for real people, places, or events. This helps viewers understand when realistic
     * content has been created or altered using AI. YouTube may add a label to videos when this is set.
     * Added to YouTube Data API in October 2024.
     *
     */
    containsSyntheticMedia?: boolean;
    /**
     * YouTube video category ID. Defaults to '22' (People & Blogs).
     * Common categories: 1 (Film & Animation), 2 (Autos & Vehicles), 10 (Music),
     * 15 (Pets & Animals), 17 (Sports), 20 (Gaming), 22 (People & Blogs),
     * 23 (Comedy), 24 (Entertainment), 25 (News & Politics), 26 (Howto & Style),
     * 27 (Education), 28 (Science & Technology).
     *
     */
    categoryId?: string;
};

export type YouTubeScopeMissingResponse = {
    success?: boolean;
    error?: string;
    code?: string;
    scopeStatus?: {
        hasAnalyticsScope?: boolean;
        requiresReauthorization?: boolean;
        /**
         * URL to redirect user for reauthorization
         */
        reauthorizeUrl?: string;
    };
};

export type DownloadYouTubeVideoData = {
    query: {
        /**
         * Action to perform: 'download' returns download URL, 'formats' lists available formats
         */
        action?: 'download' | 'formats';
        /**
         * Desired format (when action=download)
         */
        format?: 'video' | 'audio';
        /**
         * Specific format ID from formats list
         */
        formatId?: string;
        /**
         * Desired quality (when action=download)
         */
        quality?: 'hd' | 'sd';
        /**
         * YouTube video URL or video ID
         */
        url: string;
    };
};

export type DownloadYouTubeVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    formats?: Array<{
        id?: string;
        label?: string;
        ext?: string;
        type?: string;
        height?: number;
        width?: number;
    }>;
});

export type DownloadYouTubeVideoError = ({
    error?: string;
} | unknown);

export type GetYouTubeTranscriptData = {
    query: {
        /**
         * Language code for transcript
         */
        lang?: string;
        /**
         * YouTube video URL or video ID
         */
        url: string;
    };
};

export type GetYouTubeTranscriptResponse = ({
    success?: boolean;
    videoId?: string;
    language?: string;
    fullText?: string;
    segments?: Array<{
        text?: string;
        start?: number;
        duration?: number;
    }>;
});

export type GetYouTubeTranscriptError = (unknown);

export type DownloadInstagramMediaData = {
    query: {
        /**
         * Instagram reel or post URL
         */
        url: string;
    };
};

export type DownloadInstagramMediaResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadInstagramMediaError = unknown;

export type CheckInstagramHashtagsData = {
    body: {
        hashtags: Array<(string)>;
    };
};

export type CheckInstagramHashtagsResponse = ({
    success?: boolean;
    results?: Array<{
        hashtag?: string;
        status?: 'banned' | 'restricted' | 'safe' | 'unknown';
        reason?: string;
        confidence?: number;
    }>;
    summary?: {
        banned?: number;
        restricted?: number;
        safe?: number;
    };
});

export type CheckInstagramHashtagsError = unknown;

export type DownloadTikTokVideoData = {
    query: {
        /**
         * 'formats' to list available formats
         */
        action?: 'download' | 'formats';
        /**
         * Specific format ID (0 = no watermark, etc.)
         */
        formatId?: string;
        /**
         * TikTok video URL or ID
         */
        url: string;
    };
};

export type DownloadTikTokVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    formats?: Array<{
        id?: string;
        label?: string;
        ext?: string;
    }>;
});

export type DownloadTikTokVideoError = unknown;

export type DownloadTwitterMediaData = {
    query: {
        action?: 'download' | 'formats';
        formatId?: string;
        /**
         * Twitter/X post URL
         */
        url: string;
    };
};

export type DownloadTwitterMediaResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadTwitterMediaError = unknown;

export type DownloadFacebookVideoData = {
    query: {
        /**
         * Facebook video or reel URL
         */
        url: string;
    };
};

export type DownloadFacebookVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    thumbnail?: string;
});

export type DownloadFacebookVideoError = unknown;

export type DownloadLinkedInVideoData = {
    query: {
        /**
         * LinkedIn post URL
         */
        url: string;
    };
};

export type DownloadLinkedInVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadLinkedInVideoError = unknown;

export type DownloadBlueskyMediaData = {
    query: {
        /**
         * Bluesky post URL
         */
        url: string;
    };
};

export type DownloadBlueskyMediaResponse = ({
    success?: boolean;
    title?: string;
    text?: string;
    downloadUrl?: string;
    thumbnail?: string;
});

export type DownloadBlueskyMediaError = unknown;

export type GetAnalyticsData = {
    query?: {
        /**
         * Inclusive lower bound
         */
        fromDate?: string;
        /**
         * Page size (default 50)
         */
        limit?: number;
        /**
         * Sort order
         */
        order?: 'asc' | 'desc';
        /**
         * Page number (default 1)
         */
        page?: number;
        /**
         * Filter by platform (default "all")
         */
        platform?: string;
        /**
         * Returns analytics for a single post. Accepts both Late Post IDs (from `POST /v1/posts`)
         * and External Post IDs (from this endpoint's list response). The API automatically
         * resolves Late Post IDs to their corresponding External Post analytics.
         *
         */
        postId?: string;
        /**
         * Filter by profile ID (default "all")
         */
        profileId?: string;
        /**
         * Sort by date or engagement
         */
        sortBy?: 'date' | 'engagement';
        /**
         * Filter by post source:
         * - `late` - Only posts scheduled/published via Late API
         * - `external` - Only posts synced from the platform (not posted via Late)
         * - `all` - All posts (default)
         *
         */
        source?: 'all' | 'late' | 'external';
        /**
         * Inclusive upper bound
         */
        toDate?: string;
    };
};

export type GetAnalyticsResponse = ((AnalyticsSinglePostResponse | AnalyticsListResponse));

export type GetAnalyticsError = ({
    error?: string;
} | {
    error?: string;
    code?: string;
} | ErrorResponse);

export type GetYouTubeDailyViewsData = {
    query: {
        /**
         * The Late account ID for the YouTube account
         */
        accountId: string;
        /**
         * End date (YYYY-MM-DD). Defaults to 3 days ago (YouTube data latency).
         */
        endDate?: string;
        /**
         * Start date (YYYY-MM-DD). Defaults to 30 days ago.
         */
        startDate?: string;
        /**
         * The YouTube video ID (e.g., "dQw4w9WgXcQ")
         */
        videoId: string;
    };
};

export type GetYouTubeDailyViewsResponse = (YouTubeDailyViewsResponse);

export type GetYouTubeDailyViewsError = ({
    error?: string;
} | {
    error?: string;
    code?: string;
} | YouTubeScopeMissingResponse | {
    success?: boolean;
    error?: string;
});

export type ListAccountGroupsResponse = ({
    groups?: Array<{
        _id?: string;
        name?: string;
        accountIds?: Array<(string)>;
    }>;
});

export type ListAccountGroupsError = ({
    error?: string;
});

export type CreateAccountGroupData = {
    body: {
        name: string;
        accountIds: Array<(string)>;
    };
};

export type CreateAccountGroupResponse = ({
    message?: string;
    group?: {
        _id?: string;
        name?: string;
        accountIds?: Array<(string)>;
    };
});

export type CreateAccountGroupError = (unknown | {
    error?: string;
});

export type UpdateAccountGroupData = {
    body: {
        name?: string;
        accountIds?: Array<(string)>;
    };
    path: {
        groupId: string;
    };
};

export type UpdateAccountGroupResponse = ({
    message?: string;
    group?: {
        [key: string]: unknown;
    };
});

export type UpdateAccountGroupError = ({
    error?: string;
} | unknown);

export type DeleteAccountGroupData = {
    path: {
        groupId: string;
    };
};

export type DeleteAccountGroupResponse = ({
    message?: string;
});

export type DeleteAccountGroupError = ({
    error?: string;
});

export type GetMediaPresignedUrlData = {
    body: {
        /**
         * Name of the file to upload
         */
        filename: string;
        /**
         * MIME type of the file
         */
        contentType: 'image/jpeg' | 'image/jpg' | 'image/png' | 'image/webp' | 'image/gif' | 'video/mp4' | 'video/mpeg' | 'video/quicktime' | 'video/avi' | 'video/x-msvideo' | 'video/webm' | 'video/x-m4v' | 'application/pdf';
        /**
         * Optional file size in bytes for pre-validation (max 5GB)
         */
        size?: number;
    };
};

export type GetMediaPresignedUrlResponse = ({
    /**
     * Presigned URL to PUT your file to (expires in 1 hour)
     */
    uploadUrl?: string;
    /**
     * Public URL where the file will be accessible after upload
     */
    publicUrl?: string;
    /**
     * Storage key/path of the file
     */
    key?: string;
    /**
     * Detected file type based on content type
     */
    type?: 'image' | 'video' | 'document';
});

export type GetMediaPresignedUrlError = ({
    error?: string;
});

export type SearchRedditData = {
    query: {
        accountId: string;
        after?: string;
        limit?: number;
        q: string;
        restrict_sr?: '0' | '1';
        sort?: 'relevance' | 'hot' | 'top' | 'new' | 'comments';
        subreddit?: string;
    };
};

export type SearchRedditResponse = ({
    posts?: Array<{
        id?: string;
        title?: string;
        selftext?: string;
        author?: string;
        subreddit?: string;
        score?: number;
        num_comments?: number;
        created_utc?: number;
        permalink?: string;
    }>;
    after?: string;
});

export type SearchRedditError = (unknown | {
    error?: string;
});

export type GetRedditFeedData = {
    query: {
        accountId: string;
        after?: string;
        limit?: number;
        sort?: 'hot' | 'new' | 'top' | 'rising';
        subreddit?: string;
        t?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    };
};

export type GetRedditFeedResponse = ({
    posts?: Array<{
        [key: string]: unknown;
    }>;
    after?: string;
});

export type GetRedditFeedError = (unknown | {
    error?: string;
});

export type GetUsageStatsResponse = (UsageStats);

export type GetUsageStatsError = ({
    error?: string;
});

export type ListPostsData = {
    query?: {
        createdBy?: string;
        dateFrom?: string;
        dateTo?: string;
        includeHidden?: boolean;
        /**
         * Page size
         */
        limit?: number;
        /**
         * Page number (1-based)
         */
        page?: number;
        platform?: string;
        profileId?: string;
        status?: 'draft' | 'scheduled' | 'published' | 'failed';
    };
};

export type ListPostsResponse = (PostsListResponse);

export type ListPostsError = ({
    error?: string;
});

export type CreatePostData = {
    body: {
        title?: string;
        /**
         * Post caption/text content. Optional when media is attached (images, videos, etc.).
         * Required for text-only posts. Can also be omitted if all platforms have customContent set.
         *
         */
        content?: string;
        mediaItems?: Array<{
            type?: 'image' | 'video' | 'gif' | 'document';
            url?: string;
        }>;
        platforms?: Array<{
            platform?: string;
            accountId?: string;
            customContent?: string;
            customMedia?: Array<{
                type?: 'image' | 'video' | 'gif' | 'document';
                url?: string;
            }>;
            /**
             * Optional per-platform scheduled time override. When omitted, the top-level scheduledFor is used.
             */
            scheduledFor?: string;
            platformSpecificData?: (TwitterPlatformData | ThreadsPlatformData | FacebookPlatformData | InstagramPlatformData | LinkedInPlatformData | PinterestPlatformData | YouTubePlatformData | TikTokPlatformData | TelegramPlatformData | SnapchatPlatformData);
        }>;
        scheduledFor?: string;
        publishNow?: boolean;
        isDraft?: boolean;
        timezone?: string;
        /**
         * Tags/keywords for the post. YouTube-specific constraints:
         * - No count limit; duplicates are automatically removed
         * - Each tag must be ≤ 100 characters
         * - Combined total across all tags ≤ 500 characters (YouTube's limit)
         *
         */
        tags?: Array<(string)>;
        hashtags?: Array<(string)>;
        mentions?: Array<(string)>;
        crosspostingEnabled?: boolean;
        metadata?: {
            [key: string]: unknown;
        };
        /**
         * Root-level TikTok settings applied to all TikTok platforms in the request.
         * This is a convenience shorthand. Settings here are merged into each TikTok
         * platform's platformSpecificData, with platform-specific settings taking precedence.
         *
         */
        tiktokSettings?: TikTokPlatformData;
        /**
         * Profile ID to schedule via queue.
         *
         * When provided (without `scheduledFor`), the post will be automatically assigned
         * to the next available slot from the profile's queue. The system uses distributed
         * locking to prevent race conditions when multiple posts are scheduled concurrently.
         * Do not call `/v1/queue/next-slot` and then use that time in `scheduledFor`.
         * That bypasses the queue system and can cause duplicate slot assignments.
         *
         */
        queuedFromProfile?: string;
        /**
         * Specific queue ID to use when scheduling via queue.
         * Only used when queuedFromProfile is also provided.
         * If omitted, uses the profile's default queue.
         *
         */
        queueId?: string;
    };
};

export type CreatePostResponse = (PostCreateResponse);

export type CreatePostError = ({
    error?: string;
} | {
    error?: string;
    details?: {
        accountId?: string;
        platform?: string;
        existingPostId?: string;
    };
} | {
    error?: string;
    /**
     * Additional context about the rate limit
     */
    details?: {
        [key: string]: unknown;
    };
});

export type GetPostData = {
    path: {
        postId: string;
    };
};

export type GetPostResponse = (PostGetResponse);

export type GetPostError = ({
    error?: string;
} | unknown);

export type UpdatePostData = {
    body: {
        [key: string]: unknown;
    };
    path: {
        postId: string;
    };
};

export type UpdatePostResponse = (PostUpdateResponse | unknown);

export type UpdatePostError = (unknown | {
    error?: string;
});

export type DeletePostData = {
    path: {
        postId: string;
    };
};

export type DeletePostResponse = (PostDeleteResponse);

export type DeletePostError = (unknown | {
    error?: string;
});

export type BulkUploadPostsData = {
    body: {
        file?: (Blob | File);
    };
    query?: {
        dryRun?: boolean;
    };
};

export type BulkUploadPostsResponse = ({
    success?: boolean;
    totalRows?: number;
    created?: number;
    failed?: number;
    errors?: Array<{
        row?: number;
        error?: string;
    }>;
    posts?: Array<Post>;
} | unknown);

export type BulkUploadPostsError = (unknown | {
    error?: string;
} | {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
});

export type RetryPostData = {
    path: {
        postId: string;
    };
};

export type RetryPostResponse = (PostRetryResponse | unknown);

export type RetryPostError = (unknown | {
    error?: string;
} | {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
});

export type ListUsersResponse = ({
    currentUserId?: string;
    users?: Array<{
        _id?: string;
        name?: string;
        email?: string;
        role?: string;
        isRoot?: boolean;
        profileAccess?: Array<(string)>;
        createdAt?: string;
    }>;
});

export type ListUsersError = ({
    error?: string;
});

export type GetUserData = {
    path: {
        userId: string;
    };
};

export type GetUserResponse = ({
    user?: {
        _id?: string;
        name?: string;
        email?: string;
        role?: string;
        isRoot?: boolean;
        profileAccess?: Array<(string)>;
    };
});

export type GetUserError = ({
    error?: string;
} | unknown);

export type ListProfilesData = {
    query?: {
        /**
         * When true, includes profiles that exceed the user's plan limit.
         * Over-limit profiles will have `isOverLimit: true` in the response.
         * Useful for managing/deleting profiles after a plan downgrade.
         *
         */
        includeOverLimit?: boolean;
    };
};

export type ListProfilesResponse = (ProfilesListResponse);

export type ListProfilesError = ({
    error?: string;
});

export type CreateProfileData = {
    body: {
        name: string;
        description?: string;
        color?: string;
    };
};

export type CreateProfileResponse = (ProfileCreateResponse);

export type CreateProfileError = (unknown | {
    error?: string;
});

export type GetProfileData = {
    path: {
        profileId: string;
    };
};

export type GetProfileResponse = ({
    profile?: Profile;
});

export type GetProfileError = ({
    error?: string;
});

export type UpdateProfileData = {
    body: {
        name?: string;
        description?: string;
        color?: string;
        isDefault?: boolean;
    };
    path: {
        profileId: string;
    };
};

export type UpdateProfileResponse = ({
    message?: string;
    profile?: Profile;
});

export type UpdateProfileError = ({
    error?: string;
});

export type DeleteProfileData = {
    path: {
        profileId: string;
    };
};

export type DeleteProfileResponse = ({
    message?: string;
});

export type DeleteProfileError = (unknown | {
    error?: string;
});

export type ListAccountsData = {
    query?: {
        /**
         * When true, includes accounts from profiles that exceed the user's plan limit.
         * Useful for disconnecting accounts from over-limit profiles so they can be deleted.
         *
         */
        includeOverLimit?: boolean;
        /**
         * Filter accounts by profile ID
         */
        profileId?: string;
    };
};

export type ListAccountsResponse = ({
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
});

export type ListAccountsError = ({
    error?: string;
});

export type GetFollowerStatsData = {
    query?: {
        /**
         * Comma-separated list of account IDs (optional, defaults to all user's accounts)
         */
        accountIds?: string;
        /**
         * Start date in YYYY-MM-DD format (defaults to 30 days ago)
         */
        fromDate?: string;
        /**
         * Data aggregation level
         */
        granularity?: 'daily' | 'weekly' | 'monthly';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * End date in YYYY-MM-DD format (defaults to today)
         */
        toDate?: string;
    };
};

export type GetFollowerStatsResponse = ({
    accounts?: Array<AccountWithFollowerStats>;
    stats?: {
        [key: string]: Array<{
            date?: string;
            followers?: number;
        }>;
    };
    dateRange?: {
        from?: string;
        to?: string;
    };
    granularity?: string;
});

export type GetFollowerStatsError = ({
    error?: string;
} | {
    error?: string;
    message?: string;
    requiresAddon?: boolean;
});

export type UpdateAccountData = {
    body: {
        username?: string;
        displayName?: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateAccountResponse = ({
    message?: string;
    username?: string;
    displayName?: string;
});

export type UpdateAccountError = (unknown | {
    error?: string;
});

export type DeleteAccountData = {
    path: {
        accountId: string;
    };
};

export type DeleteAccountResponse = ({
    message?: string;
});

export type DeleteAccountError = ({
    error?: string;
});

export type GetAllAccountsHealthData = {
    query?: {
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'linkedin' | 'twitter' | 'tiktok' | 'youtube' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Filter by health status
         */
        status?: 'healthy' | 'warning' | 'error';
    };
};

export type GetAllAccountsHealthResponse = ({
    summary?: {
        /**
         * Total number of accounts
         */
        total?: number;
        /**
         * Number of healthy accounts
         */
        healthy?: number;
        /**
         * Number of accounts with warnings
         */
        warning?: number;
        /**
         * Number of accounts with errors
         */
        error?: number;
        /**
         * Number of accounts needing reconnection
         */
        needsReconnect?: number;
    };
    accounts?: Array<{
        accountId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
        profileId?: string;
        status?: 'healthy' | 'warning' | 'error';
        canPost?: boolean;
        canFetchAnalytics?: boolean;
        tokenValid?: boolean;
        tokenExpiresAt?: string;
        needsReconnect?: boolean;
        issues?: Array<(string)>;
    }>;
});

export type GetAllAccountsHealthError = ({
    error?: string;
});

export type GetAccountHealthData = {
    path: {
        /**
         * The account ID to check
         */
        accountId: string;
    };
};

export type GetAccountHealthResponse = ({
    accountId?: string;
    platform?: string;
    username?: string;
    displayName?: string;
    /**
     * Overall health status
     */
    status?: 'healthy' | 'warning' | 'error';
    tokenStatus?: {
        /**
         * Whether the token is valid
         */
        valid?: boolean;
        expiresAt?: string;
        /**
         * Human-readable time until expiry
         */
        expiresIn?: string;
        /**
         * Whether token expires within 24 hours
         */
        needsRefresh?: boolean;
    };
    permissions?: {
        posting?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        analytics?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        optional?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        canPost?: boolean;
        canFetchAnalytics?: boolean;
        missingRequired?: Array<(string)>;
    };
    /**
     * List of issues found
     */
    issues?: Array<(string)>;
    /**
     * Actionable recommendations to fix issues
     */
    recommendations?: Array<(string)>;
});

export type GetAccountHealthError = ({
    error?: string;
});

export type ListApiKeysResponse = ({
    apiKeys?: Array<ApiKey>;
});

export type ListApiKeysError = ({
    error?: string;
});

export type CreateApiKeyData = {
    body: {
        name: string;
        /**
         * Days until expiry
         */
        expiresIn?: number;
    };
};

export type CreateApiKeyResponse = ({
    message?: string;
    apiKey?: ApiKey;
});

export type CreateApiKeyError = (unknown | {
    error?: string;
});

export type DeleteApiKeyData = {
    path: {
        keyId: string;
    };
};

export type DeleteApiKeyResponse = ({
    message?: string;
});

export type DeleteApiKeyError = ({
    error?: string;
});

export type CreateInviteTokenData = {
    body: {
        /**
         * 'all' grants access to all profiles, 'profiles' restricts to specific profiles
         */
        scope: 'all' | 'profiles';
        /**
         * Required if scope is 'profiles'. Array of profile IDs to grant access to.
         */
        profileIds?: Array<(string)>;
    };
};

export type CreateInviteTokenResponse = ({
    token?: string;
    scope?: string;
    invitedProfileIds?: Array<(string)>;
    expiresAt?: string;
    inviteUrl?: string;
});

export type CreateInviteTokenError = (unknown | {
    error?: string;
});

export type GetConnectUrlData = {
    path: {
        /**
         * Social media platform to connect
         */
        platform: 'facebook' | 'instagram' | 'linkedin' | 'twitter' | 'tiktok' | 'youtube' | 'threads' | 'reddit' | 'pinterest' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
    };
    query: {
        /**
         * Your Late profile ID (get from /v1/profiles)
         */
        profileId: string;
        /**
         * Optional: Your custom redirect URL after connection completes.
         *
         * **Standard Mode:** Omit `headless=true` to use our hosted page selection UI.
         * After the user selects a Facebook Page, Late redirects here with:
         * `?connected=facebook&profileId=X&username=Y`
         *
         * **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile & Snapchat):**
         * Pass `headless=true` as a query parameter on this endpoint (not inside `redirect_url`), e.g.:
         * `GET /v1/connect/facebook?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
         * `GET /v1/connect/linkedin?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
         * `GET /v1/connect/pinterest?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
         * `GET /v1/connect/googlebusiness?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
         * `GET /v1/connect/snapchat?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
         *
         * After OAuth, the user is redirected directly to your `redirect_url` with OAuth data:
         * - **Facebook:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=facebook&step=select_page`
         * - **LinkedIn:** `?profileId=X&pendingDataToken=TOKEN&connect_token=CT&platform=linkedin&step=select_organization`
         * Use `GET /v1/connect/pending-data?token=TOKEN` to fetch tempToken, userProfile, organizations, refreshToken.
         * - **Pinterest:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=pinterest&step=select_board`
         * - **Google Business:** `?profileId=X&tempToken=Y&userProfile=Z&connect_token=CT&platform=googlebusiness&step=select_location`
         * - **Snapchat:** `?profileId=X&tempToken=Y&userProfile=Z&publicProfiles=PROFILES&connect_token=CT&platform=snapchat&step=select_public_profile`
         * (publicProfiles contains `id`, `display_name`, `username`, `profile_image_url`, `subscriber_count`)
         *
         * Then use the respective endpoints to build your custom UI:
         * - Facebook: `/v1/connect/facebook/select-page` (GET to fetch, POST to save)
         * - LinkedIn: `/v1/connect/linkedin/organizations` (GET to fetch logos), `/v1/connect/linkedin/select-organization` (POST to save)
         * - Pinterest: `/v1/connect/pinterest/select-board` (GET to fetch, POST to save)
         * - Google Business: `/v1/connect/googlebusiness/locations` (GET) and `/v1/connect/googlebusiness/select-location` (POST)
         * - Snapchat: `/v1/connect/snapchat/select-profile` (POST to save selected public profile)
         *
         * Example: `https://yourdomain.com/integrations/callback`
         *
         */
        redirect_url?: string;
    };
};

export type GetConnectUrlResponse = ({
    /**
     * URL to redirect your user to for OAuth authorization
     */
    authUrl?: string;
    /**
     * State parameter for security (handled automatically)
     */
    state?: string;
});

export type GetConnectUrlError = (unknown | {
    error?: string;
});

export type HandleOAuthCallbackData = {
    body: {
        code: string;
        state: string;
        profileId: string;
    };
    path: {
        platform: string;
    };
};

export type HandleOAuthCallbackResponse = (unknown);

export type HandleOAuthCallbackError = (unknown | {
    error?: string;
});

export type ListFacebookPagesData = {
    query: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * Temporary Facebook access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListFacebookPagesResponse = ({
    pages?: Array<{
        /**
         * Facebook Page ID
         */
        id?: string;
        /**
         * Page name
         */
        name?: string;
        /**
         * Page username/handle (may be null)
         */
        username?: string;
        /**
         * Page-specific access token
         */
        access_token?: string;
        /**
         * Page category
         */
        category?: string;
        /**
         * User permissions for this page
         */
        tasks?: Array<(string)>;
    }>;
});

export type ListFacebookPagesError = (unknown | {
    error?: string;
});

export type SelectFacebookPageData = {
    body: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * The Facebook Page ID selected by the user
         */
        pageId: string;
        /**
         * Temporary Facebook access token from OAuth
         */
        tempToken: string;
        /**
         * Decoded user profile object from the OAuth callback
         */
        userProfile?: {
            id?: string;
            name?: string;
            profilePicture?: string;
        };
        /**
         * Optional custom redirect URL to return to after selection
         */
        redirect_url?: string;
    };
};

export type SelectFacebookPageResponse = ({
    message?: string;
    /**
     * Redirect URL if custom redirect_url was provided
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'facebook';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        selectedPageName?: string;
    };
});

export type SelectFacebookPageError = (unknown | {
    error?: string;
});

export type ListGoogleBusinessLocationsData = {
    query: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * Temporary Google access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListGoogleBusinessLocationsResponse = ({
    locations?: Array<{
        /**
         * Location ID
         */
        id?: string;
        /**
         * Business name
         */
        name?: string;
        /**
         * Google Business Account ID
         */
        accountId?: string;
        /**
         * Account name
         */
        accountName?: string;
        /**
         * Business address
         */
        address?: string;
        /**
         * Business category
         */
        category?: string;
    }>;
});

export type ListGoogleBusinessLocationsError = (unknown | {
    error?: string;
});

export type SelectGoogleBusinessLocationData = {
    body: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * The Google Business location ID selected by the user
         */
        locationId: string;
        /**
         * Temporary Google access token from OAuth
         */
        tempToken: string;
        /**
         * Decoded user profile object from the OAuth callback. **Important:** This contains
         * the refresh token needed for token refresh. Always include this field.
         *
         */
        userProfile?: {
            id?: string;
            name?: string;
            /**
             * Google refresh token for long-lived access
             */
            refreshToken?: string;
            /**
             * Token expiration time in seconds
             */
            tokenExpiresIn?: number;
            /**
             * Granted OAuth scopes
             */
            scope?: string;
        };
        /**
         * Optional custom redirect URL to return to after selection
         */
        redirect_url?: string;
    };
};

export type SelectGoogleBusinessLocationResponse = ({
    message?: string;
    /**
     * Redirect URL if custom redirect_url was provided
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'googlebusiness';
        username?: string;
        displayName?: string;
        isActive?: boolean;
        selectedLocationName?: string;
        selectedLocationId?: string;
    };
});

export type SelectGoogleBusinessLocationError = (unknown | {
    error?: string;
});

export type GetGoogleBusinessReviewsData = {
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
    query?: {
        /**
         * Number of reviews to fetch per page (max 50)
         */
        pageSize?: number;
        /**
         * Pagination token from previous response
         */
        pageToken?: string;
    };
};

export type GetGoogleBusinessReviewsResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    reviews?: Array<{
        /**
         * Review ID
         */
        id?: string;
        /**
         * Full resource name
         */
        name?: string;
        reviewer?: {
            displayName?: string;
            profilePhotoUrl?: (string) | null;
            isAnonymous?: boolean;
        };
        /**
         * Numeric star rating
         */
        rating?: number;
        /**
         * Google's string rating
         */
        starRating?: 'ONE' | 'TWO' | 'THREE' | 'FOUR' | 'FIVE';
        /**
         * Review text
         */
        comment?: string;
        createTime?: string;
        updateTime?: string;
        reviewReply?: {
            /**
             * Business owner reply
             */
            comment?: string;
            updateTime?: string;
        } | null;
    }>;
    /**
     * Overall average rating
     */
    averageRating?: number;
    /**
     * Total number of reviews
     */
    totalReviewCount?: number;
    /**
     * Token for next page
     */
    nextPageToken?: (string) | null;
});

export type GetGoogleBusinessReviewsError = (ErrorResponse | {
    error?: string;
});

export type GetGoogleBusinessFoodMenusData = {
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
};

export type GetGoogleBusinessFoodMenusResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    /**
     * Resource name of the food menus
     */
    name?: string;
    menus?: Array<FoodMenu>;
});

export type GetGoogleBusinessFoodMenusError = (ErrorResponse | {
    error?: string;
});

export type UpdateGoogleBusinessFoodMenusData = {
    body: {
        /**
         * Array of food menus to set
         */
        menus: Array<FoodMenu>;
        /**
         * Field mask for partial updates (e.g. "menus")
         */
        updateMask?: string;
    };
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
};

export type UpdateGoogleBusinessFoodMenusResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    name?: string;
    menus?: Array<FoodMenu>;
});

export type UpdateGoogleBusinessFoodMenusError = (ErrorResponse | {
    error?: string;
});

export type GetPendingOAuthDataData = {
    query: {
        /**
         * The pending data token from the OAuth redirect URL (`pendingDataToken` parameter)
         */
        token: string;
    };
};

export type GetPendingOAuthDataResponse = ({
    /**
     * The platform (e.g., "linkedin")
     */
    platform?: string;
    /**
     * The Late profile ID
     */
    profileId?: string;
    /**
     * Temporary access token for the platform
     */
    tempToken?: string;
    /**
     * Refresh token (if available)
     */
    refreshToken?: string;
    /**
     * Token expiry in seconds
     */
    expiresIn?: number;
    /**
     * User profile data (id, username, displayName, profilePicture)
     */
    userProfile?: {
        [key: string]: unknown;
    };
    /**
     * Type of selection data
     */
    selectionType?: 'organizations' | 'pages' | 'boards' | 'locations' | 'profiles';
    /**
     * LinkedIn organizations (when selectionType is "organizations")
     */
    organizations?: Array<{
        id?: string;
        urn?: string;
        name?: string;
        vanityName?: string;
    }>;
});

export type GetPendingOAuthDataError = (ErrorResponse);

export type ListLinkedInOrganizationsData = {
    query: {
        /**
         * Comma-separated list of organization IDs to fetch details for (max 100)
         */
        orgIds: string;
        /**
         * The temporary LinkedIn access token from the OAuth redirect
         */
        tempToken: string;
    };
};

export type ListLinkedInOrganizationsResponse = ({
    organizations?: Array<{
        /**
         * Organization ID
         */
        id?: string;
        /**
         * Logo URL (may be absent if no logo)
         */
        logoUrl?: string;
        /**
         * Organization's vanity name/slug
         */
        vanityName?: string;
        /**
         * Organization's website URL
         */
        website?: string;
        /**
         * Organization's primary industry
         */
        industry?: string;
        /**
         * Organization's description
         */
        description?: string;
    }>;
});

export type ListLinkedInOrganizationsError = ({
    error?: string;
} | unknown);

export type SelectLinkedInOrganizationData = {
    body: {
        profileId: string;
        tempToken: string;
        userProfile: {
            [key: string]: unknown;
        };
        accountType: 'personal' | 'organization';
        selectedOrganization?: {
            [key: string]: unknown;
        };
        redirect_url?: string;
    };
};

export type SelectLinkedInOrganizationResponse = ({
    message?: string;
    /**
     * The redirect URL with connection params appended (only if redirect_url was provided in request)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'linkedin';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        accountType?: 'personal' | 'organization';
    };
    bulkRefresh?: {
        updatedCount?: number;
        errors?: number;
    };
});

export type SelectLinkedInOrganizationError = (unknown | {
    error?: string;
});

export type ListPinterestBoardsForSelectionData = {
    headers: {
        /**
         * Short-lived connect token from the OAuth redirect
         */
        'X-Connect-Token': string;
    };
    query: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * Temporary Pinterest access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListPinterestBoardsForSelectionResponse = ({
    boards?: Array<{
        /**
         * Pinterest Board ID
         */
        id?: string;
        /**
         * Board name
         */
        name?: string;
        /**
         * Board description
         */
        description?: string;
        /**
         * Board privacy setting
         */
        privacy?: string;
    }>;
});

export type ListPinterestBoardsForSelectionError = (unknown | {
    error?: string;
});

export type SelectPinterestBoardData = {
    body: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * The Pinterest Board ID selected by the user
         */
        boardId: string;
        /**
         * The board name (for display purposes)
         */
        boardName?: string;
        /**
         * Temporary Pinterest access token from OAuth
         */
        tempToken: string;
        /**
         * User profile data from OAuth redirect
         */
        userProfile?: {
            [key: string]: unknown;
        };
        /**
         * Pinterest refresh token (if available)
         */
        refreshToken?: string;
        /**
         * Token expiration time in seconds
         */
        expiresIn?: number;
        /**
         * Custom redirect URL after connection completes
         */
        redirect_url?: string;
    };
};

export type SelectPinterestBoardResponse = ({
    message?: string;
    /**
     * Redirect URL with connection params (if provided)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'pinterest';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        defaultBoardName?: string;
    };
});

export type SelectPinterestBoardError = (unknown | {
    error?: string;
});

export type ListSnapchatProfilesData = {
    headers: {
        /**
         * Short-lived connect token from the OAuth redirect
         */
        'X-Connect-Token': string;
    };
    query: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * Temporary Snapchat access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListSnapchatProfilesResponse = ({
    publicProfiles?: Array<{
        /**
         * Snapchat Public Profile ID
         */
        id?: string;
        /**
         * Public profile display name
         */
        display_name?: string;
        /**
         * Public profile username/handle
         */
        username?: string;
        /**
         * Profile image URL
         */
        profile_image_url?: string;
        /**
         * Number of subscribers
         */
        subscriber_count?: number;
    }>;
});

export type ListSnapchatProfilesError = (unknown | {
    error?: string;
});

export type SelectSnapchatProfileData = {
    body: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * The selected Snapchat Public Profile
         */
        selectedPublicProfile: {
            /**
             * Snapchat Public Profile ID
             */
            id: string;
            /**
             * Display name of the public profile
             */
            display_name: string;
            /**
             * Username/handle
             */
            username?: string;
            /**
             * Profile image URL
             */
            profile_image_url?: string;
            /**
             * Number of subscribers
             */
            subscriber_count?: number;
        };
        /**
         * Temporary Snapchat access token from OAuth
         */
        tempToken: string;
        /**
         * User profile data from OAuth redirect
         */
        userProfile: {
            [key: string]: unknown;
        };
        /**
         * Snapchat refresh token (if available)
         */
        refreshToken?: string;
        /**
         * Token expiration time in seconds
         */
        expiresIn?: number;
        /**
         * Custom redirect URL after connection completes
         */
        redirect_url?: string;
    };
    headers?: {
        /**
         * Short-lived connect token from the OAuth redirect (for API users)
         */
        'X-Connect-Token'?: string;
    };
};

export type SelectSnapchatProfileResponse = ({
    message?: string;
    /**
     * Redirect URL with connection params (if provided in request)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'snapchat';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        publicProfileName?: string;
    };
});

export type SelectSnapchatProfileError = (unknown | {
    error?: string;
});

export type ConnectBlueskyCredentialsData = {
    body: {
        /**
         * Your Bluesky handle (e.g. user.bsky.social) or email address
         */
        identifier: string;
        /**
         * App password generated from Bluesky Settings > App Passwords
         */
        appPassword: string;
        /**
         * Required state parameter formatted as `{userId}-{profileId}`.
         * - `userId`: Your Late user ID (get from `GET /v1/users` → `currentUserId`)
         * - `profileId`: The profile ID to connect the account to (get from `GET /v1/profiles`)
         *
         */
        state: string;
        /**
         * Optional URL to redirect to after successful connection
         */
        redirectUri?: string;
    };
};

export type ConnectBlueskyCredentialsResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type ConnectBlueskyCredentialsError = (unknown | {
    error?: string;
});

export type GetTelegramConnectStatusData = {
    query: {
        /**
         * The profile ID to connect the Telegram account to
         */
        profileId: string;
    };
};

export type GetTelegramConnectStatusResponse = ({
    /**
     * The access code to send to the Telegram bot
     */
    code?: string;
    /**
     * When the code expires
     */
    expiresAt?: string;
    /**
     * Seconds until expiration
     */
    expiresIn?: number;
    /**
     * The Telegram bot username to message
     */
    botUsername?: string;
    /**
     * Step-by-step connection instructions
     */
    instructions?: Array<(string)>;
});

export type GetTelegramConnectStatusError = (unknown | {
    error?: string;
});

export type InitiateTelegramConnectData = {
    body: {
        /**
         * The Telegram chat ID. Can be:
         * - Numeric ID (e.g., "-1001234567890")
         * - Username with @ prefix (e.g., "@mychannel")
         *
         */
        chatId: string;
        /**
         * The profile ID to connect the account to
         */
        profileId: string;
    };
};

export type InitiateTelegramConnectResponse = ({
    message?: string;
    account?: {
        _id?: string;
        platform?: 'telegram';
        username?: string;
        displayName?: string;
        isActive?: boolean;
        chatType?: 'channel' | 'group' | 'supergroup' | 'private';
    };
});

export type InitiateTelegramConnectError = (unknown | {
    error?: string;
});

export type CompleteTelegramConnectData = {
    query: {
        /**
         * The access code to check status for
         */
        code: string;
    };
};

export type CompleteTelegramConnectResponse = (({
    status?: 'pending';
    expiresAt?: string;
    /**
     * Seconds until expiration
     */
    expiresIn?: number;
} | {
    status?: 'connected';
    chatId?: string;
    chatTitle?: string;
    chatType?: 'channel' | 'group' | 'supergroup';
    account?: {
        _id?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
} | {
    status?: 'expired';
    message?: string;
}));

export type CompleteTelegramConnectError = ({
    error?: string;
} | unknown);

export type GetFacebookPagesData = {
    path: {
        accountId: string;
    };
};

export type GetFacebookPagesResponse = ({
    pages?: Array<{
        id?: string;
        name?: string;
        username?: string;
        category?: string;
        fan_count?: number;
    }>;
    selectedPageId?: string;
    cached?: boolean;
});

export type GetFacebookPagesError = ({
    error?: string;
} | unknown);

export type UpdateFacebookPageData = {
    body: {
        selectedPageId: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateFacebookPageResponse = ({
    message?: string;
    selectedPage?: {
        id?: string;
        name?: string;
    };
});

export type UpdateFacebookPageError = (unknown | {
    error?: string;
});

export type GetLinkedInOrganizationsData = {
    path: {
        accountId: string;
    };
};

export type GetLinkedInOrganizationsResponse = ({
    organizations?: Array<{
        id?: string;
        name?: string;
        vanityName?: string;
        localizedName?: string;
    }>;
});

export type GetLinkedInOrganizationsError = ({
    error?: string;
} | unknown);

export type GetLinkedInAggregateAnalyticsData = {
    path: {
        /**
         * The ID of the LinkedIn personal account
         */
        accountId: string;
    };
    query?: {
        /**
         * Type of aggregation for the analytics data.
         * - `TOTAL` (default): Returns single totals for each metric
         * - `DAILY`: Returns daily breakdown of metrics
         *
         * Note: `MEMBERS_REACHED` metric is not available with `DAILY` aggregation.
         *
         */
        aggregation?: 'TOTAL' | 'DAILY';
        /**
         * End date for analytics data in YYYY-MM-DD format (exclusive).
         * If provided without startDate, startDate defaults to 30 days before endDate.
         *
         */
        endDate?: string;
        /**
         * Comma-separated list of metrics to fetch. If omitted, fetches all available metrics.
         * Valid values: IMPRESSION, MEMBERS_REACHED, REACTION, COMMENT, RESHARE
         *
         */
        metrics?: string;
        /**
         * Start date for analytics data in YYYY-MM-DD format.
         * If provided without endDate, endDate defaults to today.
         * If omitted entirely, returns lifetime analytics.
         *
         */
        startDate?: string;
    };
};

export type GetLinkedInAggregateAnalyticsResponse = ((LinkedInAggregateAnalyticsTotalResponse | LinkedInAggregateAnalyticsDailyResponse));

export type GetLinkedInAggregateAnalyticsError = ({
    error?: string;
    code?: string;
    validOptions?: Array<(string)>;
} | {
    error?: string;
} | {
    error?: string;
    code?: string;
} | {
    error?: string;
    code?: string;
    requiredScope?: string;
    action?: string;
} | unknown);

export type GetLinkedInPostAnalyticsData = {
    path: {
        /**
         * The ID of the LinkedIn account
         */
        accountId: string;
    };
    query: {
        /**
         * The LinkedIn post URN
         */
        urn: string;
    };
};

export type GetLinkedInPostAnalyticsResponse = ({
    accountId?: string;
    platform?: string;
    accountType?: 'personal' | 'organization';
    username?: string;
    postUrn?: string;
    analytics?: {
        /**
         * Times the post was shown
         */
        impressions?: number;
        /**
         * Unique members who saw the post
         */
        reach?: number;
        /**
         * Reactions on the post
         */
        likes?: number;
        /**
         * Comments on the post
         */
        comments?: number;
        /**
         * Reshares of the post
         */
        shares?: number;
        /**
         * Clicks on the post (organization accounts only)
         */
        clicks?: number;
        /**
         * Video views (video posts only)
         */
        views?: number;
        /**
         * Engagement rate as percentage
         */
        engagementRate?: number;
    };
    lastUpdated?: string;
});

export type GetLinkedInPostAnalyticsError = ({
    error?: string;
    code?: 'missing_urn' | 'invalid_urn' | 'invalid_platform';
} | {
    error?: string;
} | unknown | {
    error?: string;
    code?: string;
    requiredScope?: string;
    action?: string;
} | {
    error?: string;
    code?: string;
});

export type UpdateLinkedInOrganizationData = {
    body: {
        accountType: 'personal' | 'organization';
        selectedOrganization?: {
            [key: string]: unknown;
        };
    };
    path: {
        accountId: string;
    };
};

export type UpdateLinkedInOrganizationResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type UpdateLinkedInOrganizationError = (unknown | {
    error?: string;
});

export type GetLinkedInMentionsData = {
    path: {
        /**
         * The LinkedIn account ID
         */
        accountId: string;
    };
    query: {
        /**
         * The exact display name as shown on LinkedIn.
         * - **Person mentions:** Required for clickable mentions. If not provided, a name is derived from the vanity URL which may not match exactly.
         * - **Organization mentions:** Optional. If not provided, the company name is automatically retrieved from LinkedIn.
         *
         */
        displayName?: string;
        /**
         * LinkedIn profile URL, company URL, or vanity name.
         * - Person: `miquelpalet`, `linkedin.com/in/miquelpalet`
         * - Organization: `company/microsoft`, `linkedin.com/company/microsoft`
         *
         */
        url: string;
    };
};

export type GetLinkedInMentionsResponse = ({
    /**
     * The LinkedIn URN (person or organization)
     */
    urn?: string;
    /**
     * The type of entity (person or organization)
     */
    type?: 'person' | 'organization';
    /**
     * Display name (provided, from API, or derived from vanity URL)
     */
    displayName?: string;
    /**
     * Ready-to-use mention format for post content
     */
    mentionFormat?: string;
    /**
     * The vanity name/slug (only for organization mentions)
     */
    vanityName?: string;
    /**
     * Warning about clickable mentions (only present for person mentions if displayName was not provided)
     */
    warning?: string;
});

export type GetLinkedInMentionsError = ({
    error?: string;
});

export type GetPinterestBoardsData = {
    path: {
        accountId: string;
    };
};

export type GetPinterestBoardsResponse = ({
    boards?: Array<{
        id?: string;
        name?: string;
        description?: string;
        privacy?: string;
    }>;
});

export type GetPinterestBoardsError = (unknown | {
    error?: string;
});

export type UpdatePinterestBoardsData = {
    body: {
        defaultBoardId: string;
        defaultBoardName?: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdatePinterestBoardsResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type UpdatePinterestBoardsError = (unknown | {
    error?: string;
});

export type GetGmbLocationsData = {
    path: {
        accountId: string;
    };
};

export type GetGmbLocationsResponse = ({
    locations?: Array<{
        id?: string;
        name?: string;
        accountId?: string;
        accountName?: string;
        address?: string;
        category?: string;
        websiteUrl?: string;
    }>;
    selectedLocationId?: string;
    cached?: boolean;
});

export type GetGmbLocationsError = ({
    error?: string;
} | unknown);

export type UpdateGmbLocationData = {
    body: {
        selectedLocationId: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateGmbLocationResponse = ({
    message?: string;
    selectedLocation?: {
        id?: string;
        name?: string;
    };
});

export type UpdateGmbLocationError = (unknown | {
    error?: string;
});

export type GetRedditSubredditsData = {
    path: {
        accountId: string;
    };
};

export type GetRedditSubredditsResponse = ({
    subreddits?: Array<{
        /**
         * Reddit subreddit ID
         */
        id?: string;
        /**
         * Subreddit name without r/ prefix
         */
        name?: string;
        /**
         * Subreddit title
         */
        title?: string;
        /**
         * Subreddit URL path
         */
        url?: string;
        /**
         * Whether the subreddit is NSFW
         */
        over18?: boolean;
    }>;
    /**
     * Currently set default subreddit for posting
     */
    defaultSubreddit?: string;
});

export type GetRedditSubredditsError = (unknown | {
    error?: string;
});

export type UpdateRedditSubredditsData = {
    body: {
        defaultSubreddit: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateRedditSubredditsResponse = ({
    success?: boolean;
});

export type UpdateRedditSubredditsError = (unknown | {
    error?: string;
});

export type ListQueueSlotsData = {
    query: {
        /**
         * Set to 'true' to list all queues for the profile
         */
        all?: 'true';
        /**
         * Profile ID to get queues for
         */
        profileId: string;
        /**
         * Specific queue ID to retrieve (optional)
         */
        queueId?: string;
    };
};

export type ListQueueSlotsResponse = (({
    exists?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
} | {
    queues?: Array<QueueSchedule>;
    count?: number;
}));

export type ListQueueSlotsError = (unknown | {
    error?: string;
});

export type CreateQueueSlotData = {
    body: {
        /**
         * Profile ID
         */
        profileId: string;
        /**
         * Queue name (e.g., Evening Posts)
         */
        name: string;
        /**
         * IANA timezone
         */
        timezone: string;
        slots: Array<QueueSlot>;
        active?: boolean;
    };
};

export type CreateQueueSlotResponse = ({
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
});

export type CreateQueueSlotError = (unknown | {
    error?: string;
});

export type UpdateQueueSlotData = {
    body: {
        profileId: string;
        /**
         * Queue ID to update (optional)
         */
        queueId?: string;
        /**
         * Queue name
         */
        name?: string;
        timezone: string;
        slots: Array<QueueSlot>;
        active?: boolean;
        /**
         * Make this queue the default
         */
        setAsDefault?: boolean;
        /**
         * Whether to reschedule existing queued posts to match new slots
         */
        reshuffleExisting?: boolean;
    };
};

export type UpdateQueueSlotResponse = ({
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
    reshuffledCount?: number;
});

export type UpdateQueueSlotError = (unknown | {
    error?: string;
});

export type DeleteQueueSlotData = {
    query: {
        profileId: string;
        /**
         * Queue ID to delete
         */
        queueId: string;
    };
};

export type DeleteQueueSlotResponse = ({
    success?: boolean;
    deleted?: boolean;
});

export type DeleteQueueSlotError = (unknown | {
    error?: string;
});

export type PreviewQueueData = {
    query: {
        count?: number;
        profileId: string;
    };
};

export type PreviewQueueResponse = ({
    profileId?: string;
    count?: number;
    slots?: Array<(string)>;
});

export type PreviewQueueError = (unknown | {
    error?: string;
});

export type GetNextQueueSlotData = {
    query: {
        profileId: string;
        /**
         * Specific queue ID (optional, defaults to profile's default queue)
         */
        queueId?: string;
    };
};

export type GetNextQueueSlotResponse = ({
    profileId?: string;
    nextSlot?: string;
    timezone?: string;
    /**
     * Queue ID this slot belongs to
     */
    queueId?: string;
    /**
     * Queue name
     */
    queueName?: string;
});

export type GetNextQueueSlotError = (unknown | {
    error?: string;
});

export type GetWebhookSettingsResponse = ({
    webhooks?: Array<Webhook>;
});

export type GetWebhookSettingsError = ({
    error?: string;
});

export type CreateWebhookSettingsData = {
    body: {
        /**
         * Webhook name (max 50 characters)
         */
        name?: string;
        /**
         * Webhook endpoint URL (must be HTTPS in production)
         */
        url?: string;
        /**
         * Secret key for HMAC-SHA256 signature verification
         */
        secret?: string;
        /**
         * Events to subscribe to
         */
        events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received')>;
        /**
         * Enable or disable webhook delivery
         */
        isActive?: boolean;
        /**
         * Custom headers to include in webhook requests
         */
        customHeaders?: {
            [key: string]: (string);
        };
    };
};

export type CreateWebhookSettingsResponse = ({
    success?: boolean;
    webhook?: Webhook;
});

export type CreateWebhookSettingsError = (unknown | {
    error?: string;
});

export type UpdateWebhookSettingsData = {
    body: {
        /**
         * Webhook ID to update (required)
         */
        _id: string;
        /**
         * Webhook name (max 50 characters)
         */
        name?: string;
        /**
         * Webhook endpoint URL (must be HTTPS in production)
         */
        url?: string;
        /**
         * Secret key for HMAC-SHA256 signature verification
         */
        secret?: string;
        /**
         * Events to subscribe to
         */
        events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received')>;
        /**
         * Enable or disable webhook delivery
         */
        isActive?: boolean;
        /**
         * Custom headers to include in webhook requests
         */
        customHeaders?: {
            [key: string]: (string);
        };
    };
};

export type UpdateWebhookSettingsResponse = ({
    success?: boolean;
    webhook?: Webhook;
});

export type UpdateWebhookSettingsError = (unknown | {
    error?: string;
});

export type DeleteWebhookSettingsData = {
    query: {
        /**
         * Webhook ID to delete
         */
        id: string;
    };
};

export type DeleteWebhookSettingsResponse = ({
    success?: boolean;
});

export type DeleteWebhookSettingsError = (unknown | {
    error?: string;
});

export type TestWebhookData = {
    body: {
        /**
         * ID of the webhook to test
         */
        webhookId: string;
    };
};

export type TestWebhookResponse = ({
    success?: boolean;
    message?: string;
});

export type TestWebhookError = (unknown | {
    error?: string;
} | {
    success?: boolean;
    message?: string;
});

export type GetWebhookLogsData = {
    query?: {
        /**
         * Filter by event type
         */
        event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'webhook.test';
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
        /**
         * Filter by delivery status
         */
        status?: 'success' | 'failed';
        /**
         * Filter by webhook ID
         */
        webhookId?: string;
    };
};

export type GetWebhookLogsResponse = ({
    logs?: Array<WebhookLog>;
});

export type GetWebhookLogsError = ({
    error?: string;
});

export type ListLogsData = {
    query?: {
        /**
         * Filter by action type
         */
        action?: 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled' | 'all';
        /**
         * Number of days to look back (max 7)
         */
        days?: number;
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
        /**
         * Filter by platform
         */
        platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat' | 'all';
        /**
         * Number of logs to skip (for pagination)
         */
        skip?: number;
        /**
         * Filter by log status
         */
        status?: 'success' | 'failed' | 'pending' | 'skipped' | 'all';
    };
};

export type ListLogsResponse = ({
    logs?: Array<PostLog>;
    pagination?: {
        /**
         * Total number of logs matching the query
         */
        total?: number;
        limit?: number;
        skip?: number;
        /**
         * Total number of pages
         */
        pages?: number;
        hasMore?: boolean;
    };
});

export type ListLogsError = ({
    error?: string;
});

export type GetLogData = {
    path: {
        /**
         * The log entry ID
         */
        logId: string;
    };
};

export type GetLogResponse = ({
    log?: PostLogDetail;
});

export type GetLogError = ({
    error?: string;
} | unknown);

export type GetPostLogsData = {
    path: {
        /**
         * The post ID
         */
        postId: string;
    };
    query?: {
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
    };
};

export type GetPostLogsResponse = ({
    logs?: Array<PostLog>;
    /**
     * Number of logs returned
     */
    count?: number;
    postId?: string;
});

export type GetPostLogsError = ({
    error?: string;
} | unknown);

export type ListInboxConversationsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        /**
         * Pagination cursor for next page
         */
        cursor?: string;
        /**
         * Maximum number of conversations to return
         */
        limit?: number;
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'twitter' | 'bluesky' | 'reddit' | 'telegram';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Sort order by updated time
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by conversation status
         */
        status?: 'active' | 'archived';
    };
};

export type ListInboxConversationsResponse = ({
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        participantId?: string;
        participantName?: string;
        participantPicture?: (string) | null;
        lastMessage?: string;
        updatedTime?: string;
        status?: 'active' | 'archived';
        /**
         * Number of unread messages
         */
        unreadCount?: (number) | null;
        /**
         * Direct link to open the conversation on the platform (if available)
         */
        url?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
});

export type ListInboxConversationsError = ({
    error?: string;
} | unknown);

export type GetInboxConversationData = {
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
    query: {
        /**
         * The social account ID
         */
        accountId: string;
    };
};

export type GetInboxConversationResponse = ({
    data?: {
        id?: string;
        accountId?: string;
        accountUsername?: string;
        platform?: string;
        status?: 'active' | 'archived';
        participantName?: string;
        participantId?: string;
        lastMessage?: string;
        lastMessageAt?: string;
        updatedTime?: string;
        participants?: Array<{
            id?: string;
            name?: string;
        }>;
    };
});

export type GetInboxConversationError = ({
    error?: string;
} | unknown);

export type UpdateInboxConversationData = {
    body: {
        /**
         * Social account ID
         */
        accountId: string;
        status: 'active' | 'archived';
    };
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
};

export type UpdateInboxConversationResponse = ({
    success?: boolean;
    data?: {
        id?: string;
        accountId?: string;
        status?: 'active' | 'archived';
        platform?: string;
        updatedAt?: string;
    };
});

export type UpdateInboxConversationError = ({
    error?: string;
} | unknown);

export type GetInboxConversationMessagesData = {
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
    query: {
        /**
         * Social account ID
         */
        accountId: string;
    };
};

export type GetInboxConversationMessagesResponse = ({
    status?: string;
    messages?: Array<{
        id?: string;
        conversationId?: string;
        accountId?: string;
        platform?: string;
        message?: string;
        senderId?: string;
        senderName?: (string) | null;
        direction?: 'incoming' | 'outgoing';
        createdAt?: string;
        attachments?: Array<{
            id?: string;
            type?: 'image' | 'video' | 'audio' | 'file' | 'sticker' | 'share';
            url?: string;
            filename?: (string) | null;
            previewUrl?: (string) | null;
        }>;
        /**
         * Reddit message subject
         */
        subject?: (string) | null;
        /**
         * Instagram story reply
         */
        storyReply?: (boolean) | null;
        /**
         * Instagram story mention
         */
        isStoryMention?: (boolean) | null;
    }>;
    lastUpdated?: string;
});

export type GetInboxConversationMessagesError = ({
    error?: string;
} | unknown);

export type SendInboxMessageData = {
    body: {
        /**
         * Social account ID
         */
        accountId: string;
        /**
         * Message text
         */
        message: string;
    };
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
};

export type SendInboxMessageResponse = ({
    success?: boolean;
    data?: {
        /**
         * ID of the sent message (not returned for Reddit)
         */
        messageId?: string;
        /**
         * Twitter conversation ID
         */
        conversationId?: (string) | null;
        /**
         * Bluesky sent timestamp
         */
        sentAt?: (string) | null;
        /**
         * Success message (Reddit only)
         */
        message?: (string) | null;
    };
});

export type SendInboxMessageError = ({
    error?: string;
    code?: 'PLATFORM_LIMITATION';
} | {
    error?: string;
} | unknown);

export type ListInboxCommentsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        cursor?: string;
        limit?: number;
        /**
         * Minimum comment count
         */
        minComments?: number;
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'twitter' | 'bluesky' | 'threads' | 'youtube' | 'linkedin' | 'reddit' | 'tiktok';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Posts created after this date
         */
        since?: string;
        /**
         * Sort field
         */
        sortBy?: 'date' | 'comments';
        /**
         * Sort order
         */
        sortOrder?: 'asc' | 'desc';
    };
};

export type ListInboxCommentsResponse = ({
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        content?: string;
        picture?: (string) | null;
        permalink?: (string) | null;
        createdTime?: string;
        commentCount?: number;
        likeCount?: number;
        /**
         * Bluesky content identifier
         */
        cid?: (string) | null;
        /**
         * Reddit subreddit name
         */
        subreddit?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
});

export type ListInboxCommentsError = ({
    error?: string;
} | unknown);

export type GetInboxPostCommentsData = {
    path: {
        postId: string;
    };
    query: {
        accountId: string;
        /**
         * (Reddit only) Get replies to a specific comment
         */
        commentId?: string;
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Maximum number of comments to return
         */
        limit?: number;
        /**
         * (Reddit only) Subreddit name
         */
        subreddit?: string;
    };
};

export type GetInboxPostCommentsResponse = ({
    status?: string;
    comments?: Array<{
        id?: string;
        message?: string;
        createdTime?: string;
        from?: {
            id?: string;
            name?: string;
            username?: string;
            picture?: (string) | null;
            isOwner?: boolean;
        };
        likeCount?: number;
        replyCount?: number;
        /**
         * The platform this comment is from
         */
        platform?: string;
        /**
         * Direct link to the comment on the platform (if available)
         */
        url?: (string) | null;
        replies?: Array<{
            [key: string]: unknown;
        }>;
        canReply?: boolean;
        canDelete?: boolean;
        /**
         * Whether this comment can be hidden (Facebook
         */
        canHide?: boolean;
        /**
         * Whether this comment can be liked (Facebook
         */
        canLike?: boolean;
        /**
         * Whether the comment is currently hidden
         */
        isHidden?: boolean;
        /**
         * Whether the current user has liked this comment
         */
        isLiked?: boolean;
        /**
         * Bluesky like URI for unliking
         */
        likeUri?: (string) | null;
        /**
         * Bluesky content identifier
         */
        cid?: (string) | null;
        /**
         * Parent comment ID for nested replies
         */
        parentId?: (string) | null;
        /**
         * Bluesky root post URI
         */
        rootUri?: (string) | null;
        /**
         * Bluesky root post CID
         */
        rootCid?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        cursor?: (string) | null;
    };
    meta?: {
        platform?: string;
        postId?: string;
        accountId?: string;
        /**
         * (Reddit only) Subreddit name
         */
        subreddit?: (string) | null;
        lastUpdated?: string;
    };
});

export type GetInboxPostCommentsError = ({
    error?: string;
} | unknown);

export type ReplyToInboxPostData = {
    body: {
        accountId: string;
        message: string;
        /**
         * Reply to specific comment (optional)
         */
        commentId?: string;
        /**
         * (Reddit only) Subreddit name for replies
         */
        subreddit?: string;
        /**
         * (Bluesky only) Parent content identifier
         */
        parentCid?: string;
        /**
         * (Bluesky only) Root post URI
         */
        rootUri?: string;
        /**
         * (Bluesky only) Root post CID
         */
        rootCid?: string;
    };
    path: {
        postId: string;
    };
};

export type ReplyToInboxPostResponse = ({
    success?: boolean;
    data?: {
        commentId?: string;
        isReply?: boolean;
        /**
         * Bluesky CID
         */
        cid?: (string) | null;
    };
});

export type ReplyToInboxPostError = ({
    error?: string;
} | unknown);

export type DeleteInboxCommentData = {
    path: {
        postId: string;
    };
    query: {
        accountId: string;
        commentId: string;
    };
};

export type DeleteInboxCommentResponse = ({
    success?: boolean;
    data?: {
        message?: string;
    };
});

export type DeleteInboxCommentError = ({
    error?: string;
} | unknown);

export type HideInboxCommentData = {
    body: {
        /**
         * The social account ID
         */
        accountId: string;
    };
    path: {
        commentId: string;
        postId: string;
    };
};

export type HideInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    hidden?: boolean;
    platform?: string;
});

export type HideInboxCommentError = (unknown | {
    error?: string;
});

export type UnhideInboxCommentData = {
    path: {
        commentId: string;
        postId: string;
    };
    query: {
        accountId: string;
    };
};

export type UnhideInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    hidden?: boolean;
    platform?: string;
});

export type UnhideInboxCommentError = (unknown | {
    error?: string;
});

export type LikeInboxCommentData = {
    body: {
        /**
         * The social account ID
         */
        accountId: string;
        /**
         * (Bluesky only) Content identifier for the comment
         */
        cid?: string;
    };
    path: {
        commentId: string;
        postId: string;
    };
};

export type LikeInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    liked?: boolean;
    /**
     * (Bluesky only) URI to use for unliking
     */
    likeUri?: string;
    platform?: string;
});

export type LikeInboxCommentError = (unknown | {
    error?: string;
});

export type UnlikeInboxCommentData = {
    path: {
        commentId: string;
        postId: string;
    };
    query: {
        accountId: string;
        /**
         * (Bluesky only) The like URI returned when liking
         */
        likeUri?: string;
    };
};

export type UnlikeInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    liked?: boolean;
    platform?: string;
});

export type UnlikeInboxCommentError = (unknown | {
    error?: string;
});

export type SendPrivateReplyToCommentData = {
    body: {
        /**
         * The Instagram social account ID
         */
        accountId: string;
        /**
         * The message text to send as a private DM
         */
        message: string;
    };
    path: {
        /**
         * The comment ID to send a private reply to
         */
        commentId: string;
        /**
         * The Instagram media/post ID
         */
        postId: string;
    };
};

export type SendPrivateReplyToCommentResponse = ({
    status?: string;
    /**
     * The ID of the sent message
     */
    messageId?: string;
    /**
     * The comment ID that was replied to
     */
    commentId?: string;
    platform?: string;
});

export type SendPrivateReplyToCommentError = ({
    error?: string;
    code?: 'PLATFORM_LIMITATION';
} | {
    error?: string;
} | unknown);

export type ListInboxReviewsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        cursor?: string;
        /**
         * Filter by reply status
         */
        hasReply?: boolean;
        limit?: number;
        maxRating?: number;
        minRating?: number;
        platform?: 'facebook' | 'googlebusiness';
        profileId?: string;
        sortBy?: 'date' | 'rating';
        sortOrder?: 'asc' | 'desc';
    };
};

export type ListInboxReviewsResponse = ({
    status?: string;
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        reviewer?: {
            id?: (string) | null;
            name?: string;
            profileImage?: (string) | null;
        };
        rating?: number;
        text?: string;
        created?: string;
        hasReply?: boolean;
        reply?: {
            id?: string;
            text?: string;
            created?: string;
        } | null;
        reviewUrl?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
    summary?: {
        totalReviews?: number;
        averageRating?: (number) | null;
    };
});

export type ListInboxReviewsError = ({
    error?: string;
} | unknown);

export type ReplyToInboxReviewData = {
    body: {
        accountId: string;
        message: string;
    };
    path: {
        /**
         * Review ID (URL-encoded for Google Business)
         */
        reviewId: string;
    };
};

export type ReplyToInboxReviewResponse = ({
    status?: string;
    reply?: {
        id?: string;
        text?: string;
        created?: string;
    };
    platform?: string;
});

export type ReplyToInboxReviewError = ({
    error?: string;
} | unknown);

export type DeleteInboxReviewReplyData = {
    body: {
        accountId: string;
    };
    path: {
        reviewId: string;
    };
};

export type DeleteInboxReviewReplyResponse = ({
    status?: string;
    message?: string;
    platform?: string;
});

export type DeleteInboxReviewReplyError = ({
    error?: string;
} | unknown);